"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var ip3country_1 = __importDefault(require("ip3country"));
var ConfigEvaluation_1 = __importDefault(require("./ConfigEvaluation"));
var EvaluationDetails_1 = require("./EvaluationDetails");
var OutputLogger_1 = __importDefault(require("./OutputLogger"));
var UserPersistentStorageHandler_1 = __importDefault(require("./UserPersistentStorageHandler"));
var core_1 = require("./utils/core");
var EvaluatorUtils_1 = require("./utils/EvaluatorUtils");
var Hashing_1 = require("./utils/Hashing");
var StatsigContext_1 = require("./utils/StatsigContext");
var CONDITION_SEGMENT_COUNT = 10 * 1000;
var USER_BUCKET_COUNT = 1000;
var Evaluator = /** @class */ (function () {
    function Evaluator(options, store) {
        this.initialized = false;
        this.store = store;
        this.initStrategyForIP3Country = options.initStrategyForIP3Country;
        this.gateOverrides = {};
        this.configOverrides = {};
        this.layerOverrides = {};
        this.persistentStore = new UserPersistentStorageHandler_1["default"](options.userPersistentStorage);
    }
    Evaluator.prototype.init = function (ctx) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.store.init(ctx)];
                    case 1:
                        _a.sent();
                        try {
                            if (this.initStrategyForIP3Country === 'lazy') {
                                setTimeout(function () {
                                    ip3country_1["default"].init();
                                }, 0);
                            }
                            else if (this.initStrategyForIP3Country !== 'none') {
                                ip3country_1["default"].init();
                            }
                        }
                        catch (err) {
                            // Ignore: this is optional
                        }
                        this.initialized = true;
                        return [2 /*return*/];
                }
            });
        });
    };
    Evaluator.prototype.overrideGate = function (gateName, value, userOrCustomID) {
        var _a;
        if (userOrCustomID === void 0) { userOrCustomID = null; }
        var overrides = (_a = this.gateOverrides[gateName]) !== null && _a !== void 0 ? _a : {};
        overrides[userOrCustomID == null ? '' : userOrCustomID] = value;
        this.gateOverrides[gateName] = overrides;
    };
    Evaluator.prototype.overrideConfig = function (configName, value, userOrCustomID) {
        var _a;
        if (userOrCustomID === void 0) { userOrCustomID = ''; }
        var overrides = (_a = this.configOverrides[configName]) !== null && _a !== void 0 ? _a : {};
        overrides[userOrCustomID == null ? '' : userOrCustomID] = value;
        this.configOverrides[configName] = overrides;
    };
    Evaluator.prototype.overrideLayer = function (layerName, value, userOrCustomID) {
        var _a;
        if (userOrCustomID === void 0) { userOrCustomID = ''; }
        var overrides = (_a = this.layerOverrides[layerName]) !== null && _a !== void 0 ? _a : {};
        overrides[userOrCustomID == null ? '' : userOrCustomID] = value;
        this.layerOverrides[layerName] = overrides;
    };
    Evaluator.prototype.checkGate = function (user, gateName, ctx) {
        var override = this.lookupGateOverride(user, gateName);
        if (override) {
            return override.withEvaluationDetails(EvaluationDetails_1.EvaluationDetails.make(this.store.getLastUpdateTime(), this.store.getInitialUpdateTime(), 'LocalOverride'));
        }
        if (this.store.getInitReason() === 'Uninitialized') {
            return new ConfigEvaluation_1["default"](false).withEvaluationDetails(EvaluationDetails_1.EvaluationDetails.uninitialized());
        }
        var gate = this.store.getGate(gateName);
        if (!gate) {
            OutputLogger_1["default"].debug("statsigSDK> Evaluating a non-existent gate ".concat(gateName));
            return this.getUnrecognizedEvaluation();
        }
        return this._evalSpec(StatsigContext_1.EvaluationContext.get(ctx.getRequestContext(), { user: user, spec: gate }));
    };
    Evaluator.prototype.getConfig = function (user, configName, ctx, skipStickyEvaluation) {
        if (skipStickyEvaluation === void 0) { skipStickyEvaluation = false; }
        var override = this.lookupConfigOverride(user, configName);
        if (override) {
            return override.withEvaluationDetails(EvaluationDetails_1.EvaluationDetails.make(this.store.getLastUpdateTime(), this.store.getInitialUpdateTime(), 'LocalOverride'));
        }
        if (this.store.getInitReason() === 'Uninitialized') {
            return new ConfigEvaluation_1["default"](false).withEvaluationDetails(EvaluationDetails_1.EvaluationDetails.uninitialized());
        }
        var config = this.store.getConfig(configName);
        if (!config) {
            OutputLogger_1["default"].debug("statsigSDK> Evaluating a non-existent config ".concat(configName));
            return this.getUnrecognizedEvaluation();
        }
        return this._evalConfig(StatsigContext_1.EvaluationContext.get(ctx.getRequestContext(), {
            user: user,
            spec: config
        }), skipStickyEvaluation);
    };
    Evaluator.prototype.getLayer = function (user, layerName, ctx) {
        var override = this.lookupLayerOverride(user, layerName);
        if (override) {
            return override.withEvaluationDetails(EvaluationDetails_1.EvaluationDetails.make(this.store.getLastUpdateTime(), this.store.getInitialUpdateTime(), 'LocalOverride'));
        }
        if (this.store.getInitReason() === 'Uninitialized') {
            return new ConfigEvaluation_1["default"](false).withEvaluationDetails(EvaluationDetails_1.EvaluationDetails.uninitialized());
        }
        var layer = this.store.getLayer(layerName);
        if (!layer) {
            OutputLogger_1["default"].debug("statsigSDK> Evaluating a non-existent layer ".concat(layerName));
            return this.getUnrecognizedEvaluation();
        }
        return this._evalLayer(StatsigContext_1.EvaluationContext.get(ctx.getRequestContext(), { user: user, spec: layer }));
    };
    Evaluator.prototype.getUserPersistedValues = function (user, idType) {
        var _a;
        return (_a = this.persistentStore.load(user, idType)) !== null && _a !== void 0 ? _a : {};
    };
    Evaluator.prototype.getClientInitializeResponse = function (inputUser, ctx, clientSDKKey, options) {
        var _this = this;
        var _a, _b, _c, _d, _e;
        if (!this.store.isServingChecks()) {
            return null;
        }
        var user = (0, core_1.cloneEnforce)(inputUser);
        var clientKeyToAppMap = this.store.getClientKeyToAppMap();
        var hashAlgo = (_a = options === null || options === void 0 ? void 0 : options.hash) !== null && _a !== void 0 ? _a : 'djb2';
        var targetAppID = null;
        var targetEntities = null;
        if (clientSDKKey != null) {
            var hashedClientKeyToAppMap = this.store.getHashedClientKeyToAppMap();
            var hashedSDKKeysToEntities = this.store.getHashedSDKKeysToEntities();
            targetAppID = (_b = hashedClientKeyToAppMap[(0, Hashing_1.djb2Hash)(clientSDKKey)]) !== null && _b !== void 0 ? _b : null;
            targetEntities = (_c = hashedSDKKeysToEntities[(0, Hashing_1.djb2Hash)(clientSDKKey)]) !== null && _c !== void 0 ? _c : null;
        }
        if (clientSDKKey != null && targetAppID == null) {
            targetAppID = (_d = clientKeyToAppMap[clientSDKKey]) !== null && _d !== void 0 ? _d : null;
        }
        var filterTargetAppID = function (spec) {
            var _a;
            if (targetAppID != null &&
                !((_a = spec.targetAppIDs) !== null && _a !== void 0 ? _a : []).includes(targetAppID)) {
                return false;
            }
            return true;
        };
        var filterGate = function (spec) {
            if (spec.entity === 'segment' || spec.entity === 'holdout') {
                return false;
            }
            if (targetEntities != null && !targetEntities.gates.includes(spec.name)) {
                return false;
            }
            return filterTargetAppID(spec);
        };
        var filterConfig = function (spec) {
            if (targetEntities != null &&
                !targetEntities.configs.includes(spec.name)) {
                return false;
            }
            return filterTargetAppID(spec);
        };
        var gates = Object.entries(this.store.getAllGates())
            .filter(function (_a) {
            var spec = _a[1];
            return filterGate(spec);
        })
            .map(function (_a) {
            var gate = _a[0], spec = _a[1];
            var localOverride = _this.gateOverrideForClientInitializeResponse(user, spec.name, options);
            var res = localOverride !== null && localOverride !== void 0 ? localOverride : _this._eval(StatsigContext_1.EvaluationContext.get(ctx.getRequestContext(), {
                user: user,
                spec: spec,
                targetAppID: targetAppID !== null && targetAppID !== void 0 ? targetAppID : undefined
            }));
            return {
                name: (0, Hashing_1.hashString)(gate, hashAlgo),
                value: res.unsupported ? false : res.value,
                rule_id: res.rule_id,
                secondary_exposures: _this.hashSecondaryExposure(res.secondary_exposures, hashAlgo),
                id_type: spec.idType
            };
        });
        var configs = Object.entries(this.store.getAllConfigs())
            .filter(function (_a) {
            var spec = _a[1];
            return filterConfig(spec);
        })
            .map(function (_a) {
            var _b, _c;
            var spec = _a[1];
            var localOverride = _this.configOverrideForClientInitializeResponse(user, spec, options);
            var res = localOverride !== null && localOverride !== void 0 ? localOverride : _this._eval(StatsigContext_1.EvaluationContext.get(ctx.getRequestContext(), {
                user: user,
                spec: spec,
                targetAppID: targetAppID !== null && targetAppID !== void 0 ? targetAppID : undefined
            }));
            var format = _this._specToInitializeResponse(spec, res, hashAlgo);
            format.id_type = (_b = spec.idType) !== null && _b !== void 0 ? _b : null;
            if (spec.entity === 'dynamic_config') {
                format.passed = res.value === true;
            }
            if (spec.entity !== 'dynamic_config' && spec.entity !== 'autotune') {
                format.is_user_in_experiment = _this._isUserAllocatedToExperiment(user, spec, ctx);
                format.is_experiment_active = _this._isExperimentActive(spec);
                if (spec.hasSharedParams) {
                    format.is_in_layer = true;
                    format.explicit_parameters = (_c = spec.explicitParameters) !== null && _c !== void 0 ? _c : [];
                    var layerValue = {};
                    var layerName = _this.store.getExperimentLayer(spec.name);
                    if (layerName != null) {
                        var layer = _this.store.getLayer(layerName);
                        if (layer != null) {
                            layerValue = layer.defaultValue;
                        }
                    }
                    format.value = __assign(__assign({}, layerValue), format.value);
                }
            }
            return format;
        });
        var layers = Object.entries(this.store.getAllLayers())
            .filter(function (_a) {
            var spec = _a[1];
            return filterTargetAppID(spec);
        })
            .map(function (_a) {
            var _b, _c, _d;
            var spec = _a[1];
            var localOverride = _this.layerOverrideForClientInitializeResponse(user, spec, options);
            var res = localOverride !== null && localOverride !== void 0 ? localOverride : _this._eval(StatsigContext_1.EvaluationContext.get(ctx.getRequestContext(), {
                user: user,
                spec: spec,
                targetAppID: targetAppID !== null && targetAppID !== void 0 ? targetAppID : undefined
            }));
            var format = _this._specToInitializeResponse(spec, res, hashAlgo);
            format.explicit_parameters = (_b = spec.explicitParameters) !== null && _b !== void 0 ? _b : [];
            if (res.config_delegate != null && res.config_delegate !== '') {
                var delegateSpec = _this.store.getConfig(res.config_delegate);
                if (delegateSpec != null) {
                    var delegateRes = _this._eval(StatsigContext_1.EvaluationContext.get(ctx.getRequestContext(), {
                        user: user,
                        spec: delegateSpec,
                        targetAppID: targetAppID !== null && targetAppID !== void 0 ? targetAppID : undefined
                    }));
                    if (delegateRes.group_name != null &&
                        delegateRes.group_name !== '') {
                        format.group_name = delegateRes.group_name;
                    }
                }
                format.allocated_experiment_name = (0, Hashing_1.hashString)(res.config_delegate, hashAlgo);
                format.is_experiment_active = _this._isExperimentActive(delegateSpec);
                format.is_user_in_experiment = _this._isUserAllocatedToExperiment(user, delegateSpec, ctx);
                format.explicit_parameters = (_c = delegateSpec === null || delegateSpec === void 0 ? void 0 : delegateSpec.explicitParameters) !== null && _c !== void 0 ? _c : [];
            }
            // By this point, undelegated secondary exposure is hashed already because it reuse same
            // array object as secondary exposures
            format.undelegated_secondary_exposures =
                (_d = res.undelegated_secondary_exposures) !== null && _d !== void 0 ? _d : [];
            return format;
        });
        var evaluatedKeys = {};
        if (user.userID) {
            evaluatedKeys['userID'] = user.userID;
        }
        if (user.customIDs && Object.keys(user.customIDs).length > 0) {
            evaluatedKeys['customIDs'] = user.customIDs;
        }
        delete user.privateAttributes;
        this.deleteUndefinedFields(user);
        var result = {
            feature_gates: Object.assign.apply(Object, __spreadArray([{}], gates.map(function (item) {
                var _a;
                return (_a = {}, _a[item.name] = item, _a);
            }), false)),
            dynamic_configs: Object.assign.apply(Object, __spreadArray([{}], configs.map(function (item) {
                var _a;
                return (_a = {}, _a[item.name] = item, _a);
            }), false)),
            layer_configs: Object.assign.apply(Object, __spreadArray([{}], layers.map(function (item) {
                var _a;
                return (_a = {}, _a[item.name] = item, _a);
            }), false)),
            sdkParams: {},
            has_updates: true,
            generator: 'statsig-node-sdk',
            sdkInfo: { sdkType: (0, core_1.getSDKType)(), sdkVersion: (0, core_1.getSDKVersion)() },
            time: this.store.getLastUpdateTime(),
            evaluated_keys: evaluatedKeys,
            hash_used: hashAlgo,
            user: user
        };
        var sessionReplayInfo = this.store.getSessionReplayInfo();
        if (sessionReplayInfo == null) {
            return result;
        }
        result.recording_blocked = sessionReplayInfo.recording_blocked;
        result.can_record_session =
            ((_e = sessionReplayInfo.recording_blocked) !== null && _e !== void 0 ? _e : false) === false;
        var random = Math.random();
        if (sessionReplayInfo.sampling_rate != null) {
            result.session_recording_rate = sessionReplayInfo.sampling_rate;
            if (random > sessionReplayInfo.sampling_rate) {
                result.can_record_session = false;
            }
        }
        var targetingGate = sessionReplayInfo.targeting_gate;
        if (targetingGate != null) {
            var res = result.feature_gates[(0, Hashing_1.hashString)(targetingGate, hashAlgo)];
            var passesTargeting = (res === null || res === void 0 ? void 0 : res.value) === true;
            if (!passesTargeting) {
                result.can_record_session = false;
            }
            result.passes_session_recording_targeting = passesTargeting;
        }
        var eventTriggers = sessionReplayInfo.session_recording_event_triggers;
        if (eventTriggers != null) {
            result.session_recording_event_triggers = {};
            for (var eventName in eventTriggers) {
                var trigger = eventTriggers[eventName];
                result.session_recording_event_triggers[eventName] = {};
                if (trigger.values != null) {
                    result.session_recording_event_triggers[eventName].values =
                        trigger.values;
                }
                if (trigger.sampling_rate != null) {
                    var passesSampling = trigger.sampling_rate == null || random <= trigger.sampling_rate;
                    result.session_recording_event_triggers[eventName].passes_sampling =
                        passesSampling;
                }
            }
        }
        var exposureTriggers = sessionReplayInfo.session_recording_exposure_triggers;
        if (exposureTriggers != null) {
            result.session_recording_exposure_triggers = {};
            for (var exposureName in exposureTriggers) {
                var trigger = exposureTriggers[exposureName];
                result.session_recording_exposure_triggers[(0, Hashing_1.hashString)(exposureName, hashAlgo)] = {};
                if (trigger.values != null) {
                    result.session_recording_exposure_triggers[(0, Hashing_1.hashString)(exposureName, hashAlgo)].values = trigger.values;
                }
                if (trigger.sampling_rate != null) {
                    var passesSampling = trigger.sampling_rate == null || random <= trigger.sampling_rate;
                    result.session_recording_exposure_triggers[(0, Hashing_1.hashString)(exposureName, hashAlgo)].passes_sampling = passesSampling;
                }
            }
        }
        return result;
    };
    Evaluator.prototype.clearAllGateOverrides = function () {
        this.gateOverrides = {};
    };
    Evaluator.prototype.clearAllConfigOverrides = function () {
        this.configOverrides = {};
    };
    Evaluator.prototype.clearAllLayerOverrides = function () {
        this.layerOverrides = {};
    };
    Evaluator.prototype.resetSyncTimerIfExited = function () {
        return this.store.resetSyncTimerIfExited();
    };
    Evaluator.prototype.syncStoreSpecs = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.store.syncConfigSpecs()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Evaluator.prototype.syncStoreIdLists = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.store.syncIdLists()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Evaluator.prototype.getFeatureGateList = function () {
        var gates = this.store.getAllGates();
        return Object.entries(gates).map(function (_a) {
            var name = _a[0], _ = _a[1];
            return name;
        });
    };
    Evaluator.prototype.getExperimentLayer = function (experimentName) {
        return this.store.getExperimentLayer(experimentName);
    };
    Evaluator.prototype.getConfigsList = function (entityType) {
        var configs = this.store.getAllConfigs();
        return Object.entries(configs)
            .filter(function (_a) {
            var _ = _a[0], config = _a[1];
            return config.entity === entityType;
        })
            .map(function (_a) {
            var name = _a[0], _ = _a[1];
            return name;
        });
    };
    Evaluator.prototype.getLayerList = function () {
        var layers = this.store.getAllLayers();
        return Object.entries(layers).map(function (_a) {
            var name = _a[0], _ = _a[1];
            return name;
        });
    };
    Evaluator.prototype.deleteUndefinedFields = function (obj) {
        for (var key in obj) {
            if (obj[key] === undefined) {
                delete obj[key];
            }
            else if (typeof obj[key] === 'object') {
                this.deleteUndefinedFields(obj[key]);
            }
        }
    };
    Evaluator.prototype.gateOverrideForClientInitializeResponse = function (user, gateName, options) {
        var _a, _b;
        var optionsOverride = (_b = (_a = options === null || options === void 0 ? void 0 : options.overrides) === null || _a === void 0 ? void 0 : _a.featureGates) === null || _b === void 0 ? void 0 : _b[gateName];
        if (optionsOverride !== undefined) {
            return new ConfigEvaluation_1["default"](optionsOverride, 'override');
        }
        if (options === null || options === void 0 ? void 0 : options.includeLocalOverrides) {
            return this.lookupGateOverride(user, gateName);
        }
        return null;
    };
    Evaluator.prototype.configOverrideForClientInitializeResponse = function (user, spec, options) {
        var _a, _b;
        var optionsOverride = this.configBasedOverrideForClientInitializeResponse(spec, (_b = (_a = options === null || options === void 0 ? void 0 : options.overrides) === null || _a === void 0 ? void 0 : _a.dynamicConfigs) === null || _b === void 0 ? void 0 : _b[spec.name]);
        if (optionsOverride) {
            return optionsOverride;
        }
        if (options === null || options === void 0 ? void 0 : options.includeLocalOverrides) {
            return this.lookupConfigOverride(user, spec.name);
        }
        return null;
    };
    Evaluator.prototype.layerOverrideForClientInitializeResponse = function (user, spec, options) {
        var _a, _b;
        var optionsOverride = this.configBasedOverrideForClientInitializeResponse(spec, (_b = (_a = options === null || options === void 0 ? void 0 : options.overrides) === null || _a === void 0 ? void 0 : _a.layers) === null || _b === void 0 ? void 0 : _b[spec.name]);
        if (optionsOverride) {
            return optionsOverride;
        }
        if (options === null || options === void 0 ? void 0 : options.includeLocalOverrides) {
            return this.lookupLayerOverride(user, spec.name);
        }
        return null;
    };
    Evaluator.prototype.configBasedOverrideForClientInitializeResponse = function (spec, optionsOverride) {
        var _a, _b, _c;
        if (!optionsOverride) {
            return null;
        }
        var overrideRule = optionsOverride.groupName
            ? spec.rules.find(function (rule) {
                return (rule.groupName === optionsOverride.groupName &&
                    rule.isExperimentGroup);
            })
            : undefined;
        var value = (_a = optionsOverride.value) !== null && _a !== void 0 ? _a : overrideRule === null || overrideRule === void 0 ? void 0 : overrideRule.returnValue;
        if (!value || typeof value !== 'object') {
            return null;
        }
        return new ConfigEvaluation_1["default"](true, 'override', (_b = optionsOverride.groupName) !== null && _b !== void 0 ? _b : null, (_c = overrideRule === null || overrideRule === void 0 ? void 0 : overrideRule.idType) !== null && _c !== void 0 ? _c : 'userID', [], value);
    };
    Evaluator.prototype.lookupGateOverride = function (user, gateName) {
        var overrides = this.gateOverrides[gateName];
        if (overrides == null) {
            return null;
        }
        if (user.userID != null) {
            // check for a user level override
            var userOverride = overrides[user.userID];
            if (userOverride != null) {
                return new ConfigEvaluation_1["default"](userOverride, 'override');
            }
        }
        // check if there is a customID override
        var customIDs = user.customIDs;
        if (customIDs != null) {
            for (var customID in customIDs) {
                var id = customIDs[customID];
                var customIDOverride = overrides[id];
                if (customIDOverride != null) {
                    return new ConfigEvaluation_1["default"](customIDOverride, 'override');
                }
            }
        }
        // check if there is a global override
        var allOverride = overrides[''];
        if (allOverride != null) {
            return new ConfigEvaluation_1["default"](allOverride, 'override');
        }
        return null;
    };
    Evaluator.prototype.lookupConfigOverride = function (user, configName) {
        var overrides = this.configOverrides[configName];
        return this.lookupConfigBasedOverride(user, overrides);
    };
    Evaluator.prototype.lookupLayerOverride = function (user, layerName) {
        var overrides = this.layerOverrides[layerName];
        return this.lookupConfigBasedOverride(user, overrides);
    };
    Evaluator.prototype.lookupConfigBasedOverride = function (user, overrides) {
        if (overrides == null) {
            return null;
        }
        if (user.userID != null) {
            // check for a user level override
            var userOverride = overrides[user.userID];
            if (userOverride != null) {
                return new ConfigEvaluation_1["default"](true, 'override', null, 'userID', [], userOverride);
            }
        }
        // check if there is a customID override
        var customIDs = user.customIDs;
        if (customIDs != null) {
            for (var customID in customIDs) {
                var id = customIDs[customID];
                var customIDOverride = overrides[id];
                if (customIDOverride != null) {
                    return new ConfigEvaluation_1["default"](true, 'override', null, 'userID', [], customIDOverride);
                }
            }
        }
        // check if there is a global override
        var allOverride = overrides[''];
        if (allOverride != null) {
            return new ConfigEvaluation_1["default"](true, 'override', null, '', [], allOverride);
        }
        return null;
    };
    Evaluator.prototype._specToInitializeResponse = function (spec, res, hash) {
        var output = {
            name: (0, Hashing_1.hashString)(spec.name, hash),
            value: res.unsupported ? {} : res.json_value,
            group: res.rule_id,
            rule_id: res.rule_id,
            is_device_based: spec.idType != null && spec.idType.toLowerCase() === 'stableid',
            secondary_exposures: this.hashSecondaryExposure(res.secondary_exposures, hash)
        };
        if (res.group_name != null) {
            output.group_name = res.group_name;
        }
        if (res.explicit_parameters) {
            output.explicit_parameters = res.explicit_parameters;
        }
        return output;
    };
    Evaluator.prototype.hashSecondaryExposure = function (secondary_exposures, hash) {
        secondary_exposures.forEach(function (exposure) {
            exposure.gate = (0, Hashing_1.hashString)(exposure.gate, hash);
        });
        return secondary_exposures;
    };
    Evaluator.prototype._cleanExposures = function (exposures) {
        if (exposures.length === 0) {
            return exposures;
        }
        var seen = {};
        return exposures.filter(function (exposure) {
            if (exposure.gate.startsWith('segment:')) {
                return false;
            }
            var key = "".concat(exposure.gate, "|").concat(exposure.gateValue, "|").concat(exposure.ruleID);
            if (seen[key]) {
                return false;
            }
            seen[key] = true;
            return true;
        });
    };
    Evaluator.prototype.shutdown = function () {
        this.store.shutdown();
    };
    Evaluator.prototype.shutdownAsync = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.store.shutdownAsync()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Evaluator.prototype.getUnrecognizedEvaluation = function () {
        return new ConfigEvaluation_1["default"](false, '', null).withEvaluationDetails(EvaluationDetails_1.EvaluationDetails.make(this.store.getLastUpdateTime(), this.store.getInitialUpdateTime(), 'Unrecognized'));
    };
    Evaluator.prototype._evalConfig = function (ctx, skipStickyEvaluation) {
        if (skipStickyEvaluation === void 0) { skipStickyEvaluation = false; }
        var user = ctx.user, spec = ctx.spec, userPersistedValues = ctx.userPersistedValues, persistentAssignmentOptions = ctx.persistentAssignmentOptions;
        if (skipStickyEvaluation) {
            return this._evalSpec(ctx);
        }
        if (userPersistedValues == null || !spec.isActive) {
            this.persistentStore["delete"](user, spec.idType, spec.name);
            return this._evalSpec(ctx);
        }
        var stickyConfig = userPersistedValues[spec.name];
        var stickyEvaluation = stickyConfig
            ? ConfigEvaluation_1["default"].fromStickyValues(stickyConfig, this.store.getInitialUpdateTime())
            : null;
        if (stickyEvaluation) {
            if (persistentAssignmentOptions === null || persistentAssignmentOptions === void 0 ? void 0 : persistentAssignmentOptions.enforceTargeting) {
                var passesTargeting = this._evalTargeting(ctx);
                if (passesTargeting) {
                    return stickyEvaluation;
                }
                else {
                    return this._evalSpec(ctx);
                }
            }
            else {
                return stickyEvaluation;
            }
        }
        var evaluation = this._evalSpec(ctx);
        if (evaluation.is_experiment_group) {
            this.persistentStore.save(user, spec.idType, spec.name, evaluation);
        }
        return evaluation;
    };
    Evaluator.prototype._evalLayer = function (ctx) {
        var user = ctx.user, spec = ctx.spec, userPersistedValues = ctx.userPersistedValues, persistentAssignmentOptions = ctx.persistentAssignmentOptions;
        if (!userPersistedValues) {
            this.persistentStore["delete"](user, spec.idType, spec.name);
            return this._evalSpec(ctx);
        }
        var stickyConfig = userPersistedValues[spec.name];
        var stickyEvaluation = stickyConfig
            ? ConfigEvaluation_1["default"].fromStickyValues(stickyConfig, this.store.getInitialUpdateTime())
            : null;
        if (stickyEvaluation) {
            var delegateSpec_1 = stickyEvaluation.config_delegate
                ? this.store.getConfig(stickyEvaluation.config_delegate)
                : null;
            if (delegateSpec_1 && delegateSpec_1.isActive) {
                if (persistentAssignmentOptions === null || persistentAssignmentOptions === void 0 ? void 0 : persistentAssignmentOptions.enforceTargeting) {
                    var passesTargeting = this._evalTargeting(ctx, delegateSpec_1);
                    if (passesTargeting) {
                        return stickyEvaluation;
                    }
                    else {
                        return this._evalSpec(ctx);
                    }
                }
                else {
                    return stickyEvaluation;
                }
            }
            else {
                this.persistentStore["delete"](user, spec.idType, spec.name);
                return this._evalSpec(ctx);
            }
        }
        var evaluation = this._evalSpec(ctx);
        var delegateSpec = evaluation.config_delegate
            ? this.store.getConfig(evaluation.config_delegate)
            : null;
        if (delegateSpec && delegateSpec.isActive) {
            if (evaluation.is_experiment_group) {
                this.persistentStore.save(user, spec.idType, spec.name, evaluation);
            }
        }
        else {
            this.persistentStore["delete"](user, spec.idType, spec.name);
        }
        return evaluation;
    };
    Evaluator.prototype._evalTargeting = function (ctx, delegateSpec) {
        return (this._evalSpec(StatsigContext_1.EvaluationContext.get(ctx.getRequestContext(), {
            user: ctx.user,
            spec: delegateSpec !== null && delegateSpec !== void 0 ? delegateSpec : ctx.spec,
            onlyEvaluateTargeting: true
        })).value === false); // Fail evaluation means to pass targeting (fall through logic)
    };
    Evaluator.prototype._evalSpec = function (ctx) {
        var evaulation = this._eval(ctx);
        if (evaulation.evaluation_details) {
            return evaulation;
        }
        return evaulation.withEvaluationDetails(EvaluationDetails_1.EvaluationDetails.make(this.store.getLastUpdateTime(), this.store.getInitialUpdateTime(), this.store.getInitReason()));
    };
    Evaluator.prototype._eval = function (ctx) {
        var user = ctx.user, config = ctx.spec;
        if (!config.enabled) {
            return new ConfigEvaluation_1["default"](false, 'disabled', null, config.idType, [], config.defaultValue, undefined, // explicit parameters
            undefined, // config delegate
            config.version);
        }
        var rules = config.rules;
        if (ctx.onlyEvaluateTargeting) {
            rules = config.rules.filter(function (rule) { return rule.isTargetingRule(); });
            if (rules.length === 0) {
                return new ConfigEvaluation_1["default"](false);
            }
        }
        var secondary_exposures = [];
        for (var _i = 0, rules_1 = rules; _i < rules_1.length; _i++) {
            var rule = rules_1[_i];
            var ruleResult = this._evalRule(user, rule, ctx);
            if (ruleResult.unsupported) {
                return ConfigEvaluation_1["default"].unsupported(this.store.getLastUpdateTime(), this.store.getInitialUpdateTime(), config.version);
            }
            secondary_exposures = this._cleanExposures(secondary_exposures.concat(ruleResult.secondary_exposures));
            if (ruleResult.value === true) {
                var delegatedResult = this._evalDelegate(rule, secondary_exposures, ctx);
                if (delegatedResult) {
                    return delegatedResult;
                }
                var pass = this._evalPassPercent(user, rule, config);
                var evaluation = new ConfigEvaluation_1["default"](pass, ruleResult.rule_id, ruleResult.group_name, config.idType, secondary_exposures, pass
                    ? ruleResult.json_value
                    : config.defaultValue, config.explicitParameters, ruleResult.config_delegate, config.version);
                evaluation.setIsExperimentGroup(ruleResult.is_experiment_group);
                return evaluation;
            }
        }
        return new ConfigEvaluation_1["default"](false, 'default', null, config.idType, secondary_exposures, config.defaultValue, config.explicitParameters, undefined, // config delegate
        config.version);
    };
    Evaluator.prototype._evalDelegate = function (rule, exposures, ctx) {
        if (rule.configDelegate == null) {
            return null;
        }
        var config = this.store.getConfig(rule.configDelegate);
        if (!config) {
            return null;
        }
        var delegatedResult = this.getConfig(ctx.user, rule.configDelegate, ctx, true);
        delegatedResult.config_delegate = rule.configDelegate;
        delegatedResult.undelegated_secondary_exposures = exposures;
        delegatedResult.explicit_parameters = config.explicitParameters;
        delegatedResult.secondary_exposures = this._cleanExposures(exposures.concat(delegatedResult.secondary_exposures));
        return delegatedResult;
    };
    Evaluator.prototype._evalPassPercent = function (user, rule, config) {
        var _a, _b;
        if (rule.passPercentage === 0.0) {
            return false;
        }
        if (rule.passPercentage === 100.0) {
            return true;
        }
        var hash = (0, EvaluatorUtils_1.computeUserHash)(config.salt +
            '.' +
            ((_a = rule.salt) !== null && _a !== void 0 ? _a : rule.id) +
            '.' +
            ((_b = (0, EvaluatorUtils_1.getUnitID)(user, rule.idType)) !== null && _b !== void 0 ? _b : ''));
        return (Number(hash % BigInt(CONDITION_SEGMENT_COUNT)) < rule.passPercentage * 100);
    };
    Evaluator.prototype._evalRule = function (user, rule, ctx) {
        var _a;
        var secondaryExposures = [];
        var pass = true;
        for (var _i = 0, _b = rule.conditions; _i < _b.length; _i++) {
            var condition = _b[_i];
            var result = this._evalCondition(user, condition, ctx);
            if (result.unsupported) {
                return ConfigEvaluation_1["default"].unsupported(this.store.getLastUpdateTime(), this.store.getInitialUpdateTime(), undefined);
            }
            if (!result.passes) {
                pass = false;
            }
            if (result.exposures) {
                secondaryExposures = secondaryExposures.concat(result.exposures);
            }
        }
        var evaluation = new ConfigEvaluation_1["default"](pass, rule.id, rule.groupName, null, secondaryExposures, rule.returnValue);
        evaluation.setIsExperimentGroup((_a = rule.isExperimentGroup) !== null && _a !== void 0 ? _a : false);
        return evaluation;
    };
    Evaluator.prototype._evalCondition = function (user, condition, ctx) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        var value = null;
        var field = condition.field;
        var target = condition.targetValue;
        var idType = condition.idType;
        switch (condition.type.toLowerCase()) {
            case 'public':
                return { passes: true };
            case 'fail_gate':
            case 'pass_gate': {
                var gateResult = this.checkGate(user, target, ctx);
                if (gateResult === null || gateResult === void 0 ? void 0 : gateResult.unsupported) {
                    return { passes: false, unsupported: true };
                }
                value = gateResult === null || gateResult === void 0 ? void 0 : gateResult.value;
                var allExposures = (_a = gateResult === null || gateResult === void 0 ? void 0 : gateResult.secondary_exposures) !== null && _a !== void 0 ? _a : [];
                allExposures.push({
                    gate: String(target),
                    gateValue: String(value),
                    ruleID: (_b = gateResult === null || gateResult === void 0 ? void 0 : gateResult.rule_id) !== null && _b !== void 0 ? _b : ''
                });
                return {
                    passes: condition.type.toLowerCase() === 'fail_gate' ? !value : !!value,
                    exposures: allExposures
                };
            }
            case 'multi_pass_gate':
            case 'multi_fail_gate': {
                if (!Array.isArray(target)) {
                    return { passes: false, unsupported: true };
                }
                var gateNames = target;
                var value_1 = false;
                var exposures = [];
                for (var _i = 0, gateNames_1 = gateNames; _i < gateNames_1.length; _i++) {
                    var gateName = gateNames_1[_i];
                    var gateResult = this.checkGate(user, gateName, ctx);
                    if (gateResult === null || gateResult === void 0 ? void 0 : gateResult.unsupported) {
                        return { passes: false, unsupported: true };
                    }
                    var resValue = condition.type === 'multi_pass_gate'
                        ? gateResult.value === true
                        : gateResult.value === false;
                    exposures.push({
                        gate: String(gateName),
                        gateValue: String(gateResult === null || gateResult === void 0 ? void 0 : gateResult.value),
                        ruleID: (_c = gateResult === null || gateResult === void 0 ? void 0 : gateResult.rule_id) !== null && _c !== void 0 ? _c : ''
                    });
                    exposures = exposures.concat(gateResult.secondary_exposures);
                    if (resValue === true) {
                        value_1 = true;
                        break;
                    }
                }
                return {
                    passes: value_1,
                    exposures: exposures
                };
            }
            case 'ip_based':
                // this would apply to things like 'country', 'region', etc.
                value = (_d = (0, EvaluatorUtils_1.getFromUser)(user, field)) !== null && _d !== void 0 ? _d : this.getFromIP(user, field);
                break;
            case 'ua_based':
                // this would apply to things like 'os', 'browser', etc.
                value = (_e = (0, EvaluatorUtils_1.getFromUser)(user, field)) !== null && _e !== void 0 ? _e : (0, EvaluatorUtils_1.getFromUserAgent)(user, field);
                break;
            case 'user_field':
                value = (0, EvaluatorUtils_1.getFromUser)(user, field);
                break;
            case 'environment_field':
                value = (0, EvaluatorUtils_1.getFromEnvironment)(user, field);
                break;
            case 'current_time':
                value = Date.now();
                break;
            case 'user_bucket': {
                var salt = (_f = condition.additionalValues) === null || _f === void 0 ? void 0 : _f.salt;
                var userHash = (0, EvaluatorUtils_1.computeUserHash)(salt + '.' + ((_g = (0, EvaluatorUtils_1.getUnitID)(user, idType)) !== null && _g !== void 0 ? _g : ''));
                value = Number(userHash % BigInt(USER_BUCKET_COUNT));
                break;
            }
            case 'unit_id':
                value = (0, EvaluatorUtils_1.getUnitID)(user, idType);
                break;
            case 'target_app':
                value = ctx.clientKey
                    ? ctx.targetAppID
                    : this.store.getPrimaryTargetAppID();
                break;
            default:
                return { passes: false, unsupported: true };
        }
        var op = (_h = condition.operator) === null || _h === void 0 ? void 0 : _h.toLowerCase();
        var evalResult = false;
        switch (op) {
            // numerical
            case 'gt':
                evalResult = (0, EvaluatorUtils_1.numberCompare)(function (a, b) { return a > b; })(value, target);
                break;
            case 'gte':
                evalResult = (0, EvaluatorUtils_1.numberCompare)(function (a, b) { return a >= b; })(value, target);
                break;
            case 'lt':
                evalResult = (0, EvaluatorUtils_1.numberCompare)(function (a, b) { return a < b; })(value, target);
                break;
            case 'lte':
                evalResult = (0, EvaluatorUtils_1.numberCompare)(function (a, b) { return a <= b; })(value, target);
                break;
            // version
            case 'version_gt':
                evalResult = (0, EvaluatorUtils_1.versionCompareHelper)(function (result) { return result > 0; })(value, target);
                break;
            case 'version_gte':
                evalResult = (0, EvaluatorUtils_1.versionCompareHelper)(function (result) { return result >= 0; })(value, target);
                break;
            case 'version_lt':
                evalResult = (0, EvaluatorUtils_1.versionCompareHelper)(function (result) { return result < 0; })(value, target);
                break;
            case 'version_lte':
                evalResult = (0, EvaluatorUtils_1.versionCompareHelper)(function (result) { return result <= 0; })(value, target);
                break;
            case 'version_eq':
                evalResult = (0, EvaluatorUtils_1.versionCompareHelper)(function (result) { return result === 0; })(value, target);
                break;
            case 'version_neq':
                evalResult = (0, EvaluatorUtils_1.versionCompareHelper)(function (result) { return result !== 0; })(value, target);
                break;
            // array
            case 'any':
                if (condition.targetValueSet != null) {
                    evalResult =
                        condition.targetValueSet.has(String(value)) ||
                            condition.targetValueSet.has(String(value).toLowerCase());
                }
                else {
                    evalResult = (0, EvaluatorUtils_1.arrayAny)(value, target, (0, EvaluatorUtils_1.stringCompare)(true, function (a, b) { return a === b; }));
                }
                break;
            case 'none':
                if (condition.targetValueSet != null) {
                    evalResult =
                        !condition.targetValueSet.has(String(value)) &&
                            !condition.targetValueSet.has(String(value).toLowerCase());
                }
                else {
                    evalResult = !(0, EvaluatorUtils_1.arrayAny)(value, target, (0, EvaluatorUtils_1.stringCompare)(true, function (a, b) { return a === b; }));
                }
                break;
            case 'any_case_sensitive':
                if (condition.targetValueSet != null) {
                    evalResult = condition.targetValueSet.has(String(value));
                }
                else {
                    evalResult = (0, EvaluatorUtils_1.arrayAny)(value, target, (0, EvaluatorUtils_1.stringCompare)(false, function (a, b) { return a === b; }));
                }
                break;
            case 'none_case_sensitive':
                if (condition.targetValueSet != null) {
                    evalResult = !condition.targetValueSet.has(String(value));
                }
                else {
                    evalResult = !(0, EvaluatorUtils_1.arrayAny)(value, target, (0, EvaluatorUtils_1.stringCompare)(false, function (a, b) { return a === b; }));
                }
                break;
            // string
            case 'str_starts_with_any':
                evalResult = (0, EvaluatorUtils_1.arrayAny)(value, target, (0, EvaluatorUtils_1.stringCompare)(true, function (a, b) { return a.startsWith(b); }));
                break;
            case 'str_ends_with_any':
                evalResult = (0, EvaluatorUtils_1.arrayAny)(value, target, (0, EvaluatorUtils_1.stringCompare)(true, function (a, b) { return a.endsWith(b); }));
                break;
            case 'str_contains_any':
                evalResult = (0, EvaluatorUtils_1.arrayAny)(value, target, (0, EvaluatorUtils_1.stringCompare)(true, function (a, b) { return a.includes(b); }));
                break;
            case 'str_contains_none':
                evalResult = !(0, EvaluatorUtils_1.arrayAny)(value, target, (0, EvaluatorUtils_1.stringCompare)(true, function (a, b) { return a.includes(b); }));
                break;
            case 'str_matches':
                try {
                    if (String(value).length < 1000) {
                        evalResult = new RegExp(target).test(String(value));
                    }
                    else {
                        evalResult = false;
                    }
                }
                catch (e) {
                    evalResult = false;
                }
                break;
            // strictly equals
            case 'eq':
                evalResult = value == target;
                break;
            case 'neq':
                evalResult = value != target;
                break;
            // dates
            case 'before':
                evalResult = (0, EvaluatorUtils_1.dateCompare)(function (a, b) { return a < b; })(value, target);
                break;
            case 'after':
                evalResult = (0, EvaluatorUtils_1.dateCompare)(function (a, b) { return a > b; })(value, target);
                break;
            case 'on':
                evalResult = (0, EvaluatorUtils_1.dateCompare)(function (a, b) {
                    a === null || a === void 0 ? void 0 : a.setHours(0, 0, 0, 0);
                    b === null || b === void 0 ? void 0 : b.setHours(0, 0, 0, 0);
                    return (a === null || a === void 0 ? void 0 : a.getTime()) === (b === null || b === void 0 ? void 0 : b.getTime());
                })(value, target);
                break;
            case 'in_segment_list':
            case 'not_in_segment_list': {
                var list = (_j = this.store.getIDList(target)) === null || _j === void 0 ? void 0 : _j.ids;
                value = (0, Hashing_1.hashUnitIDForIDList)(value);
                var inList = typeof list === 'object' && list[value] === true;
                evalResult = op === 'in_segment_list' ? inList : !inList;
                break;
            }
            case 'array_contains_any': {
                if (!Array.isArray(target)) {
                    evalResult = false;
                    break;
                }
                if (!Array.isArray(value)) {
                    evalResult = false;
                    break;
                }
                evalResult = (0, EvaluatorUtils_1.arrayHasValue)(value, target);
                break;
            }
            case 'array_contains_none': {
                if (!Array.isArray(target)) {
                    evalResult = false;
                    break;
                }
                if (!Array.isArray(value)) {
                    evalResult = false;
                    break;
                }
                evalResult = !(0, EvaluatorUtils_1.arrayHasValue)(value, target);
                break;
            }
            case 'array_contains_all': {
                if (!Array.isArray(target)) {
                    evalResult = false;
                    break;
                }
                if (!Array.isArray(value)) {
                    evalResult = false;
                    break;
                }
                evalResult = (0, EvaluatorUtils_1.arrayHasAllValues)(value, target);
                break;
            }
            case 'not_array_contains_all': {
                if (!Array.isArray(target)) {
                    evalResult = false;
                    break;
                }
                if (!Array.isArray(value)) {
                    evalResult = false;
                    break;
                }
                evalResult = !(0, EvaluatorUtils_1.arrayHasAllValues)(value, target);
                break;
            }
            default:
                return { passes: false, unsupported: true };
        }
        return { passes: evalResult };
    };
    Evaluator.prototype._isExperimentActive = function (experimentConfig) {
        if (experimentConfig == null) {
            return false;
        }
        return experimentConfig.isActive === true;
    };
    Evaluator.prototype._isUserAllocatedToExperiment = function (user, experimentConfig, ctx) {
        if (experimentConfig == null) {
            return false;
        }
        var evalResult = this._eval(StatsigContext_1.EvaluationContext.get(ctx.getRequestContext(), {
            user: user,
            spec: experimentConfig
        }));
        return evalResult.is_experiment_group;
    };
    Evaluator.prototype.getFromIP = function (user, field) {
        var ip = (0, EvaluatorUtils_1.getFromUser)(user, 'ip');
        if (ip == null || field !== 'country') {
            return null;
        }
        return this.ip2country(ip);
    };
    Evaluator.prototype.ip2country = function (ip) {
        if (!this.initialized) {
            return null;
        }
        try {
            if (typeof ip === 'string') {
                return ip3country_1["default"].lookupStr(ip);
            }
            else if (typeof ip === 'number') {
                return ip3country_1["default"].lookupNumeric(ip);
            }
        }
        catch (e) {
            // TODO: log
        }
        return null;
    };
    return Evaluator;
}());
exports["default"] = Evaluator;
