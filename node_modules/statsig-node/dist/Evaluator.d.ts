import ConfigEvaluation from './ConfigEvaluation';
import { ConfigCondition, ConfigRule, ConfigSpec } from './ConfigSpec';
import { UserPersistedValues } from './interfaces/IUserPersistentStorage';
import { SecondaryExposure } from './LogEvent';
import SpecStore from './SpecStore';
import { ClientInitializeResponseOptions, ExplicitStatsigOptions } from './StatsigOptions';
import { StatsigUser } from './StatsigUser';
import { HashingAlgorithm } from './utils/Hashing';
import { EvaluationContext, InitializeContext, StatsigContext } from './utils/StatsigContext';
type InitializeResponse = {
    name: string;
    value: unknown;
    group: string;
    rule_id: string;
    is_device_based: boolean;
    secondary_exposures: Record<string, string>[];
    group_name?: string | null;
    is_experiment_active?: boolean;
    is_user_in_experiment?: boolean;
    is_in_layer?: boolean;
    allocated_experiment_name?: string;
    explicit_parameters?: string[];
    undelegated_secondary_exposures?: Record<string, string>[];
    id_type?: string;
    passed?: boolean;
};
type SessionReplayTrigger = {
    values?: string[];
    passes_sampling?: boolean;
};
export type ClientInitializeResponse = {
    feature_gates: Record<string, InitializeResponse>;
    dynamic_configs: Record<string, InitializeResponse>;
    layer_configs: Record<string, InitializeResponse>;
    sdkParams: Record<string, unknown>;
    has_updates: boolean;
    generator: 'statsig-node-sdk';
    sdkInfo: {
        sdkType: string;
        sdkVersion: string;
    };
    time: number;
    evaluated_keys: Record<string, unknown>;
    hash_used: HashingAlgorithm;
    user: StatsigUser;
    can_record_session?: boolean;
    session_recording_rate?: number;
    recording_blocked?: boolean;
    passes_session_recording_targeting?: boolean;
    session_recording_event_triggers?: Record<string, SessionReplayTrigger>;
    session_recording_exposure_triggers?: Record<string, SessionReplayTrigger>;
};
export default class Evaluator {
    private gateOverrides;
    private configOverrides;
    private layerOverrides;
    private initialized;
    private store;
    private persistentStore;
    private initStrategyForIP3Country;
    constructor(options: ExplicitStatsigOptions, store: SpecStore);
    init(ctx: InitializeContext): Promise<void>;
    overrideGate(gateName: string, value: boolean, userOrCustomID?: string | null): void;
    overrideConfig(configName: string, value: Record<string, unknown>, userOrCustomID?: string | null): void;
    overrideLayer(layerName: string, value: Record<string, unknown>, userOrCustomID?: string | null): void;
    checkGate(user: StatsigUser, gateName: string, ctx: StatsigContext): ConfigEvaluation;
    getConfig(user: StatsigUser, configName: string, ctx: StatsigContext, skipStickyEvaluation?: boolean): ConfigEvaluation;
    getLayer(user: StatsigUser, layerName: string, ctx: StatsigContext): ConfigEvaluation;
    getUserPersistedValues(user: StatsigUser, idType: string): UserPersistedValues;
    getClientInitializeResponse(inputUser: StatsigUser, ctx: StatsigContext, clientSDKKey?: string, options?: ClientInitializeResponseOptions): ClientInitializeResponse | null;
    clearAllGateOverrides(): void;
    clearAllConfigOverrides(): void;
    clearAllLayerOverrides(): void;
    resetSyncTimerIfExited(): Error | null;
    syncStoreSpecs(): Promise<void>;
    syncStoreIdLists(): Promise<void>;
    getFeatureGateList(): string[];
    getExperimentLayer(experimentName: string): string | null;
    getConfigsList(entityType: 'experiment' | 'dynamic_config' | 'autotune'): string[];
    getLayerList(): string[];
    private deleteUndefinedFields;
    private gateOverrideForClientInitializeResponse;
    private configOverrideForClientInitializeResponse;
    private layerOverrideForClientInitializeResponse;
    private configBasedOverrideForClientInitializeResponse;
    private lookupGateOverride;
    private lookupConfigOverride;
    private lookupLayerOverride;
    private lookupConfigBasedOverride;
    private _specToInitializeResponse;
    private hashSecondaryExposure;
    private _cleanExposures;
    shutdown(): void;
    shutdownAsync(): Promise<void>;
    private getUnrecognizedEvaluation;
    _evalConfig(ctx: EvaluationContext, skipStickyEvaluation?: boolean): ConfigEvaluation;
    _evalLayer(ctx: EvaluationContext): ConfigEvaluation;
    _evalTargeting(ctx: EvaluationContext, delegateSpec?: ConfigSpec): boolean;
    _evalSpec(ctx: EvaluationContext): ConfigEvaluation;
    _eval(ctx: EvaluationContext): ConfigEvaluation;
    _evalDelegate(rule: ConfigRule, exposures: SecondaryExposure[], ctx: EvaluationContext): ConfigEvaluation | null;
    _evalPassPercent(user: StatsigUser, rule: ConfigRule, config: ConfigSpec): boolean;
    _evalRule(user: StatsigUser, rule: ConfigRule, ctx: EvaluationContext): ConfigEvaluation;
    _evalCondition(user: StatsigUser, condition: ConfigCondition, ctx: EvaluationContext): {
        passes: boolean;
        unsupported?: boolean;
        exposures?: SecondaryExposure[];
    };
    _isExperimentActive(experimentConfig: ConfigSpec | null): boolean;
    _isUserAllocatedToExperiment(user: StatsigUser, experimentConfig: ConfigSpec | null, ctx: StatsigContext): boolean;
    private getFromIP;
    ip2country(ip: string | number): string | null;
}
export {};
