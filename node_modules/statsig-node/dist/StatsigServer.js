"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var uuid_1 = require("uuid");
var Diagnostics_1 = __importDefault(require("./Diagnostics"));
var DynamicConfig_1 = __importDefault(require("./DynamicConfig"));
var ErrorBoundary_1 = __importDefault(require("./ErrorBoundary"));
var Errors_1 = require("./Errors");
var Evaluator_1 = __importDefault(require("./Evaluator"));
var FeatureGate_1 = require("./FeatureGate");
var Layer_1 = __importDefault(require("./Layer"));
var LogEvent_1 = __importDefault(require("./LogEvent"));
var LogEventProcessor_1 = __importDefault(require("./LogEventProcessor"));
var OutputLogger_1 = __importDefault(require("./OutputLogger"));
var SpecStore_1 = __importDefault(require("./SpecStore"));
var StatsigOptions_1 = require("./StatsigOptions");
var core_1 = require("./utils/core");
var LogEventValidator_1 = __importDefault(require("./utils/LogEventValidator"));
var StatsigContext_1 = require("./utils/StatsigContext");
var StatsigFetcher_1 = __importDefault(require("./utils/StatsigFetcher"));
var hasLoggedNoUserIdWarning = false;
var ExposureLogging;
(function (ExposureLogging) {
    ExposureLogging["Disabled"] = "exposures_disabled";
    ExposureLogging["Enabled"] = "exposures_enabled";
})(ExposureLogging || (ExposureLogging = {}));
var ExposureCause;
(function (ExposureCause) {
    ExposureCause["Automatic"] = "automatic_exposure";
    ExposureCause["Manual"] = "manual_exposure";
})(ExposureCause || (ExposureCause = {}));
/**
 * The global statsig class for interacting with gates, configs, experiments configured in the statsig developer console.  Also used for event logging to view in the statsig console, or for analyzing experiment impacts using pulse.
 */
var StatsigServer = /** @class */ (function () {
    function StatsigServer(secretKey, options) {
        if (options === void 0) { options = {}; }
        this._pendingInitPromise = null;
        this._ready = false;
        var optionsLoggingcopy = (0, StatsigOptions_1.OptionsLoggingCopy)(options);
        this._sessionID = (0, uuid_1.v4)();
        this._secretKey = secretKey;
        this._options = (0, StatsigOptions_1.OptionsWithDefaults)(options);
        this._pendingInitPromise = null;
        this._ready = false;
        this._errorBoundary = new ErrorBoundary_1["default"](secretKey, optionsLoggingcopy, this._sessionID);
        this._fetcher = new StatsigFetcher_1["default"](this._secretKey, this._options, this._errorBoundary, this._sessionID);
        this._logger = new LogEventProcessor_1["default"](this._fetcher, this._errorBoundary, this._options, optionsLoggingcopy, this._sessionID);
        Diagnostics_1["default"].initialize({
            logger: this._logger,
            options: this._options
        });
        this._store = new SpecStore_1["default"](this._secretKey, this._fetcher, this._options);
        this._evaluator = new Evaluator_1["default"](this._options, this._store);
    }
    StatsigServer.prototype.initializeAsync = function () {
        return __awaiter(this, void 0, void 0, function () {
            var res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.initializeImpl()];
                    case 1:
                        res = _a.sent();
                        return [2 /*return*/, res.getInitDetails()];
                }
            });
        });
    };
    /**
     * Initializes the statsig server SDK. This must be called before checking gates/configs or logging events.
     * @throws Error if a Server Secret Key is not provided
     */
    StatsigServer.prototype.initializeImpl = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this._errorBoundary.capture(function (ctx) {
                        var _a;
                        if (_this._pendingInitPromise != null) {
                            return _this._pendingInitPromise;
                        }
                        if (_this._ready === true) {
                            return Promise.resolve(ctx);
                        }
                        if (!_this._options.localMode &&
                            (typeof _this._secretKey !== 'string' ||
                                _this._secretKey.length === 0 ||
                                !_this._secretKey.startsWith('secret-'))) {
                            return Promise.reject(new Errors_1.StatsigInvalidArgumentError('Invalid key provided.  You must use a Server Secret Key from the Statsig console with the node-js-server-sdk'));
                        }
                        Diagnostics_1["default"].setContext('initialize');
                        Diagnostics_1["default"].mark.overall.start({});
                        var initPromise = _this._evaluator
                            .init(ctx)
                            .then(function () { return Promise.resolve(ctx); })["finally"](function () {
                            _this._ready = true;
                            _this._pendingInitPromise = null;
                            Diagnostics_1["default"].mark.overall.end({ success: true });
                            Diagnostics_1["default"].logDiagnostics('initialize');
                            Diagnostics_1["default"].setContext('config_sync');
                        });
                        if (_this._options.initTimeoutMs != null &&
                            _this._options.initTimeoutMs > 0) {
                            _this._pendingInitPromise = Promise.race([
                                initPromise,
                                new Promise(function (resolve) {
                                    setTimeout(function () {
                                        Diagnostics_1["default"].mark.overall.end({
                                            success: false,
                                            reason: 'timeout'
                                        });
                                        Diagnostics_1["default"].logDiagnostics('initialize');
                                        Diagnostics_1["default"].setContext('config_sync');
                                        _this._ready = true;
                                        _this._pendingInitPromise = null;
                                        ctx.setFailed(new Error('Timed out waiting for initialize'));
                                        resolve(ctx);
                                    }, _this._options.initTimeoutMs);
                                }),
                            ]);
                        }
                        else {
                            _this._pendingInitPromise = initPromise;
                        }
                        return (_a = _this._pendingInitPromise) !== null && _a !== void 0 ? _a : Promise.resolve(ctx);
                    }, function (ctx, err) {
                        _this._ready = true;
                        _this._pendingInitPromise = null;
                        ctx.setFailed(err instanceof Error ? err : undefined);
                        return Promise.resolve(ctx);
                    }, StatsigContext_1.InitializeContext["new"]({
                        caller: 'initializeAsync',
                        sdkKey: this._secretKey
                    }))];
            });
        });
    };
    // #region Check Gate
    /**
     * Check the value of a gate configured in the statsig console
     * @throws Error if initialize() was not called first
     * @throws Error if the gateName is not provided or not a non-empty string
     */
    StatsigServer.prototype.checkGate = function (user, gateName, options) {
        return this.getFeatureGate(user, gateName, options).value;
    };
    StatsigServer.prototype.getFeatureGate = function (user, gateName, options) {
        var _this = this;
        var res = this._errorBoundary.capture(function (ctx) {
            return _this.getGateImpl(user, gateName, (options === null || options === void 0 ? void 0 : options.disableExposureLogging) == true
                ? ExposureLogging.Disabled
                : ExposureLogging.Enabled, ctx);
        }, function () { return (0, FeatureGate_1.makeEmptyFeatureGate)(gateName); }, StatsigContext_1.StatsigContext["new"]({ caller: 'checkGate', configName: gateName }));
        if (this._options.evaluationCallback != null) {
            this._options.evaluationCallback(res);
        }
        return res;
    };
    StatsigServer.prototype.logGateExposure = function (inputUser, gateName) {
        var _this = this;
        return this._errorBoundary.swallow(function (ctx) {
            var _a = _this.evalGate(inputUser, gateName, ctx), evaluation = _a.evaluation, user = _a.user;
            _this.logGateExposureImpl(user, gateName, evaluation, ExposureCause.Manual);
        }, StatsigContext_1.StatsigContext["new"]({ caller: 'logGateExposure', configName: gateName }));
    };
    //#endregion
    // #region Get Config
    /**
     * Checks the value of a config for a given user
     */
    StatsigServer.prototype.getConfig = function (user, configName, options) {
        var _this = this;
        var res = this._errorBoundary.capture(function (ctx) {
            return _this.getConfigImpl(user, configName, (options === null || options === void 0 ? void 0 : options.disableExposureLogging) == true
                ? ExposureLogging.Disabled
                : ExposureLogging.Enabled, ctx);
        }, function () { return new DynamicConfig_1["default"](configName); }, StatsigContext_1.StatsigContext["new"]({ caller: 'getConfig', configName: configName }));
        if (this._options.evaluationCallback != null) {
            this._options.evaluationCallback(res);
        }
        return res;
    };
    StatsigServer.prototype.logConfigExposure = function (inputUser, experimentName) {
        var _this = this;
        this._errorBoundary.swallow(function (ctx) {
            var _a = _this.evalConfig(inputUser, experimentName, ctx), evaluation = _a.evaluation, user = _a.user;
            _this.logConfigExposureImpl(user, experimentName, evaluation, ExposureCause.Manual);
        }, StatsigContext_1.StatsigContext["new"]({
            caller: 'logConfigExposure',
            configName: experimentName
        }));
    };
    //#endregion
    // #region Get Experiment
    /**
     * Checks the value of a config for a given user
     * @throws Error if initialize() was not called first
     * @throws Error if the experimentName is not provided or not a non-empty string
     */
    StatsigServer.prototype.getExperiment = function (user, experimentName, options) {
        var _this = this;
        var _a;
        var res = this._errorBoundary.capture(function (ctx) {
            return _this.getConfigImpl(user, experimentName, (options === null || options === void 0 ? void 0 : options.disableExposureLogging) == true
                ? ExposureLogging.Disabled
                : ExposureLogging.Enabled, ctx, true);
        }, function () { return new DynamicConfig_1["default"](experimentName); }, StatsigContext_1.StatsigContext["new"]({
            caller: 'getExperiment',
            configName: experimentName,
            userPersistedValues: options === null || options === void 0 ? void 0 : options.userPersistedValues,
            persistentAssignmentOptions: options === null || options === void 0 ? void 0 : options.persistentAssignmentOptions
        }));
        if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.evaluationCallback) != null) {
            this._options.evaluationCallback(res);
        }
        return res;
    };
    StatsigServer.prototype.logExperimentExposure = function (inputUser, experimentName) {
        var _this = this;
        this._errorBoundary.swallow(function (ctx) {
            var _a = _this.evalConfig(inputUser, experimentName, ctx), evaluation = _a.evaluation, user = _a.user;
            _this.logConfigExposureImpl(user, experimentName, evaluation, ExposureCause.Manual);
        }, StatsigContext_1.StatsigContext["new"]({
            caller: 'logExperimentExposure',
            configName: experimentName
        }));
    };
    StatsigServer.prototype.getExperimentLayer = function (experiment) {
        var _this = this;
        return this._errorBoundary.capture(function () {
            return _this._evaluator.getExperimentLayer(experiment);
        }, function () { return null; }, StatsigContext_1.StatsigContext["new"]({
            caller: 'getExperimentLayer',
            configName: experiment
        }));
    };
    //#endregion
    // #region Get Layer
    /**
     * Checks the value of a config for a given user
     * @throws Error if initialize() was not called first
     * @throws Error if the layerName is not provided or not a non-empty string
     */
    StatsigServer.prototype.getLayer = function (user, layerName, options) {
        var _this = this;
        var res = this._errorBoundary.capture(function (ctx) {
            return _this.getLayerImpl(user, layerName, (options === null || options === void 0 ? void 0 : options.disableExposureLogging) == true
                ? ExposureLogging.Disabled
                : ExposureLogging.Enabled, ctx);
        }, function () { return new Layer_1["default"](layerName); }, StatsigContext_1.StatsigContext["new"]({
            caller: 'getLayer',
            configName: layerName,
            userPersistedValues: options === null || options === void 0 ? void 0 : options.userPersistedValues,
            persistentAssignmentOptions: options === null || options === void 0 ? void 0 : options.persistentAssignmentOptions
        }));
        if (this._options.evaluationCallback != null) {
            this._options.evaluationCallback(res);
        }
        return res;
    };
    StatsigServer.prototype.logLayerParameterExposure = function (inputUser, layerName, parameterName) {
        var _this = this;
        this._errorBoundary.swallow(function (ctx) {
            var _a = _this.evalLayer(inputUser, layerName, ctx), evaluation = _a.evaluation, user = _a.user;
            _this.logLayerParameterExposureImpl(user, layerName, parameterName, evaluation, ExposureCause.Manual);
        }, StatsigContext_1.StatsigContext["new"]({
            caller: 'logLayerParameterExposure',
            configName: layerName
        }));
    };
    //#endregion
    StatsigServer.prototype.getUserPersistedValues = function (user, idType) {
        var _this = this;
        return this._errorBoundary.capture(function () { return _this._evaluator.getUserPersistedValues(user, idType); }, function () { return ({}); }, StatsigContext_1.StatsigContext["new"]({ caller: 'getUserPersistedValues' }));
    };
    /**
     * Log an event for data analysis and alerting or to measure the impact of an experiment
     * @throws Error if initialize() was not called first
     */
    StatsigServer.prototype.logEvent = function (user, eventName, value, metadata) {
        var _this = this;
        if (value === void 0) { value = null; }
        if (metadata === void 0) { metadata = null; }
        return this._errorBoundary.swallow(function () {
            return _this.logEventObject({
                eventName: eventName,
                user: user,
                value: value,
                metadata: metadata
            });
        }, StatsigContext_1.StatsigContext["new"]({ caller: 'logEvent' }));
    };
    StatsigServer.prototype.logEventObject = function (eventObject) {
        var _this = this;
        return this._errorBoundary.swallow(function () {
            var _a, _b, _c, _d;
            var eventName = eventObject.eventName;
            var user = (_a = eventObject.user) !== null && _a !== void 0 ? _a : null;
            var value = (_b = eventObject.value) !== null && _b !== void 0 ? _b : null;
            var metadata = (_c = eventObject.metadata) !== null && _c !== void 0 ? _c : null;
            var time = (_d = eventObject.time) !== null && _d !== void 0 ? _d : null;
            if (!(_this._ready === true && _this._logger != null)) {
                throw new Errors_1.StatsigUninitializedError();
            }
            if (LogEventValidator_1["default"].validateEventName(eventName) == null) {
                return;
            }
            if (!(0, core_1.isUserIdentifiable)(user) && !hasLoggedNoUserIdWarning) {
                hasLoggedNoUserIdWarning = true;
                OutputLogger_1["default"].warn('statsigSDK::logEvent> No valid userID was provided. Event will be logged but not associated with an identifiable user. This message is only logged once.');
            }
            user = _this._normalizeUser(user, _this._options);
            var event = new LogEvent_1["default"](eventName);
            event.setUser(user);
            event.setValue(value);
            event.setMetadata(metadata);
            if (typeof time === 'number') {
                event.setTime(time);
            }
            _this._logger.log(event);
        }, StatsigContext_1.StatsigContext["new"]({ caller: 'logEventObject' }));
    };
    /**
     * Informs the statsig SDK that the server is closing or shutting down
     * so the SDK can clean up internal state
     */
    StatsigServer.prototype.shutdown = function (timeout) {
        var _this = this;
        if (this._logger == null) {
            return;
        }
        this._errorBoundary.swallow(function () {
            _this._ready = false;
            _this._logger.shutdown(timeout);
            _this._fetcher.shutdown();
            _this._evaluator.shutdown();
        }, StatsigContext_1.StatsigContext["new"]({ caller: 'shutdown' }));
    };
    /**
     * Informs the statsig SDK that the server is closing or shutting down
     * so the SDK can clean up internal state
     * Ensures any pending promises are resolved and remaining events are flushed.
     */
    StatsigServer.prototype.shutdownAsync = function (timeout) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this._logger == null) {
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, this._errorBoundary.capture(function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            this._ready = false;
                                            return [4 /*yield*/, this._logger.shutdown(timeout)];
                                        case 1:
                                            _a.sent();
                                            this._fetcher.shutdown();
                                            return [4 /*yield*/, this._evaluator.shutdownAsync()];
                                        case 2:
                                            _a.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            }); }, function () { return Promise.resolve(); }, StatsigContext_1.StatsigContext["new"]({ caller: 'shutdownAsync' }))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    StatsigServer.prototype.flush = function (timeout) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this._errorBoundary.capture(function () {
                        if (_this._logger == null) {
                            return Promise.resolve();
                        }
                        var flushPromise;
                        if (timeout != null) {
                            var controller_1 = new AbortController();
                            var handle_1 = setTimeout(function () { return controller_1.abort(); }, timeout);
                            flushPromise = _this._logger
                                .flush(true, controller_1.signal)
                                .then(function () { return clearTimeout(handle_1); });
                        }
                        else {
                            flushPromise = _this._logger.flush(false);
                        }
                        return flushPromise;
                    }, function () { return Promise.resolve(); }, StatsigContext_1.StatsigContext["new"]({ caller: 'flush' }))];
            });
        });
    };
    StatsigServer.prototype.clearAllGateOverrides = function () {
        this._evaluator.clearAllGateOverrides();
    };
    StatsigServer.prototype.clearAllConfigOverrides = function () {
        this._evaluator.clearAllConfigOverrides();
    };
    StatsigServer.prototype.clearAllLayerOverrides = function () {
        this._evaluator.clearAllLayerOverrides();
    };
    StatsigServer.prototype.syncStoreSpecs = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._evaluator.syncStoreSpecs()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    StatsigServer.prototype.syncStoreIdLists = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._evaluator.syncStoreIdLists()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    StatsigServer.prototype.getClientInitializeResponse = function (user, clientSDKKey, options) {
        var _this = this;
        var markerID = '';
        return this._errorBoundary.capture(function (ctx) {
            if (_this._ready !== true) {
                throw new Errors_1.StatsigUninitializedError();
            }
            markerID = "gcir_".concat(Diagnostics_1["default"].getMarkerCount('get_client_initialize_response'));
            Diagnostics_1["default"].mark.getClientInitializeResponse.start({ markerID: markerID }, 'get_client_initialize_response');
            var normalizedUser = user;
            if (user.statsigEnvironment == null) {
                normalizedUser = _this._normalizeUser(user, _this._options);
            }
            var response = _this._evaluator.getClientInitializeResponse(normalizedUser, ctx, clientSDKKey, options);
            var invalidResponse = response == null ||
                (!(0, core_1.notEmptyObject)(response.feature_gates) &&
                    !(0, core_1.notEmptyObject)(response.dynamic_configs) &&
                    !(0, core_1.notEmptyObject)(response.layer_configs));
            if (invalidResponse) {
                _this._errorBoundary.logError(new Error('getClientInitializeResponse returns empty response'), ctx);
            }
            Diagnostics_1["default"].mark.getClientInitializeResponse.end({ markerID: markerID, success: !invalidResponse }, 'get_client_initialize_response');
            return response;
        }, function () {
            Diagnostics_1["default"].mark.getClientInitializeResponse.end({ markerID: markerID, success: false }, 'get_client_initialize_response');
            return null;
        }, StatsigContext_1.StatsigContext["new"]({
            caller: 'getClientInitializeResponse',
            clientKey: clientSDKKey,
            hash: options === null || options === void 0 ? void 0 : options.hash
        }));
    };
    StatsigServer.prototype.overrideGate = function (gateName, value, userOrCustomID) {
        var _this = this;
        if (userOrCustomID === void 0) { userOrCustomID = ''; }
        this._errorBoundary.swallow(function () {
            if (typeof value !== 'boolean') {
                OutputLogger_1["default"].warn('statsigSDK> Attempted to override a gate with a non boolean value');
                return;
            }
            _this._evaluator.overrideGate(gateName, value, userOrCustomID);
        }, StatsigContext_1.StatsigContext["new"]({ caller: 'overrideGate' }));
    };
    StatsigServer.prototype.overrideConfig = function (configName, value, userOrCustomID) {
        var _this = this;
        if (userOrCustomID === void 0) { userOrCustomID = ''; }
        this._errorBoundary.swallow(function () {
            if (typeof value !== 'object') {
                OutputLogger_1["default"].warn('statsigSDK> Attempted to override a config with a non object value');
                return;
            }
            _this._evaluator.overrideConfig(configName, value, userOrCustomID);
        }, StatsigContext_1.StatsigContext["new"]({ caller: 'overrideConfig' }));
    };
    StatsigServer.prototype.overrideLayer = function (layerName, value, userOrCustomID) {
        var _this = this;
        if (userOrCustomID === void 0) { userOrCustomID = ''; }
        this._errorBoundary.swallow(function () {
            if (typeof value !== 'object') {
                OutputLogger_1["default"].warn('statsigSDK> Attempted to override a layer with a non object value');
                return;
            }
            _this._evaluator.overrideLayer(layerName, value, userOrCustomID);
        }, StatsigContext_1.StatsigContext["new"]({ caller: 'overrideLayer' }));
    };
    StatsigServer.prototype.getFeatureGateList = function () {
        return this._evaluator.getFeatureGateList();
    };
    StatsigServer.prototype.getDynamicConfigList = function () {
        return this._evaluator.getConfigsList('dynamic_config');
    };
    StatsigServer.prototype.getExperimentList = function () {
        return this._evaluator.getConfigsList('experiment');
    };
    StatsigServer.prototype.getAutotuneList = function () {
        return this._evaluator.getConfigsList('autotune');
    };
    StatsigServer.prototype.getLayerList = function () {
        return this._evaluator.getLayerList();
    };
    //#region Deprecated _sync and withExposureDisabled Methods
    /**
     * @deprecated Please use checkGate instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    StatsigServer.prototype.checkGateSync = function (user, gateName) {
        return this.getFeatureGateSync(user, gateName).value;
    };
    /**
     * @deprecated Please use getFeatureGate instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    StatsigServer.prototype.getFeatureGateSync = function (user, gateName) {
        var _this = this;
        return this._errorBoundary.capture(function (ctx) { return _this.getGateImpl(user, gateName, ExposureLogging.Enabled, ctx); }, function () { return (0, FeatureGate_1.makeEmptyFeatureGate)(gateName); }, StatsigContext_1.StatsigContext["new"]({ caller: 'checkGate', configName: gateName }));
    };
    /**
     * @deprecated Please use checkGate() with CheckGateOptions instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    StatsigServer.prototype.checkGateWithExposureLoggingDisabledSync = function (user, gateName) {
        return this.getFeatureGateWithExposureLoggingDisabledSync(user, gateName)
            .value;
    };
    /**
     * @deprecated Please use getFeatureGate with CheckGateOptions instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    StatsigServer.prototype.getFeatureGateWithExposureLoggingDisabledSync = function (user, gateName) {
        var _this = this;
        return this._errorBoundary.capture(function (ctx) { return _this.getGateImpl(user, gateName, ExposureLogging.Disabled, ctx); }, function () { return (0, FeatureGate_1.makeEmptyFeatureGate)(gateName); }, StatsigContext_1.StatsigContext["new"]({
            caller: 'getFeatureGateWithExposureLoggingDisabled',
            configName: gateName
        }));
    };
    /**
     * @deprecated Please use getConfig instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    StatsigServer.prototype.getConfigSync = function (user, configName) {
        var _this = this;
        return this._errorBoundary.capture(function (ctx) {
            return _this.getConfigImpl(user, configName, ExposureLogging.Enabled, ctx);
        }, function () { return new DynamicConfig_1["default"](configName); }, StatsigContext_1.StatsigContext["new"]({ caller: 'getConfig', configName: configName }));
    };
    /**
     * @deprecated Please use getConfigWithExposureLoggingDisabled instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    StatsigServer.prototype.getConfigWithExposureLoggingDisabledSync = function (user, configName) {
        var _this = this;
        return this._errorBoundary.capture(function (ctx) {
            return _this.getConfigImpl(user, configName, ExposureLogging.Disabled, ctx);
        }, function () { return new DynamicConfig_1["default"](configName); }, StatsigContext_1.StatsigContext["new"]({
            caller: 'getConfigWithExposureLoggingDisabled',
            configName: configName
        }));
    };
    /**
     * @deprecated Please use getExperiment instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    StatsigServer.prototype.getExperimentSync = function (user, experimentName, options) {
        var _this = this;
        return this._errorBoundary.capture(function (ctx) {
            return _this.getConfigImpl(user, experimentName, ExposureLogging.Enabled, ctx);
        }, function () { return new DynamicConfig_1["default"](experimentName); }, StatsigContext_1.StatsigContext["new"]({
            caller: 'getExperiment',
            configName: experimentName,
            userPersistedValues: options === null || options === void 0 ? void 0 : options.userPersistedValues,
            persistentAssignmentOptions: options === null || options === void 0 ? void 0 : options.persistentAssignmentOptions
        }));
    };
    /**
     * @deprecated Please use getExperimentWithExposureLoggingDisabled instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    StatsigServer.prototype.getExperimentWithExposureLoggingDisabledSync = function (user, experimentName, options) {
        var _this = this;
        return this._errorBoundary.capture(function (ctx) {
            return _this.getConfigImpl(user, experimentName, ExposureLogging.Disabled, ctx);
        }, function () { return new DynamicConfig_1["default"](experimentName); }, StatsigContext_1.StatsigContext["new"]({
            caller: 'getExperimentWithExposureLoggingDisabled',
            configName: experimentName,
            userPersistedValues: options === null || options === void 0 ? void 0 : options.userPersistedValues,
            persistentAssignmentOptions: options === null || options === void 0 ? void 0 : options.persistentAssignmentOptions
        }));
    };
    /**
     * @deprecated Please use getLayer instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    StatsigServer.prototype.getLayerSync = function (user, layerName, options) {
        var _this = this;
        return this._errorBoundary.capture(function (ctx) { return _this.getLayerImpl(user, layerName, ExposureLogging.Enabled, ctx); }, function () { return new Layer_1["default"](layerName); }, StatsigContext_1.StatsigContext["new"]({
            caller: 'getLayer',
            configName: layerName,
            userPersistedValues: options === null || options === void 0 ? void 0 : options.userPersistedValues,
            persistentAssignmentOptions: options === null || options === void 0 ? void 0 : options.persistentAssignmentOptions
        }));
    };
    /**
     * @deprecated Please use getLayer with GetLayerOptions instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    StatsigServer.prototype.getLayerWithExposureLoggingDisabledSync = function (user, layerName, options) {
        var _this = this;
        return this._errorBoundary.capture(function (ctx) {
            return _this.getLayerImpl(user, layerName, ExposureLogging.Disabled, ctx);
        }, function () { return new Layer_1["default"](layerName); }, StatsigContext_1.StatsigContext["new"]({
            caller: 'getLayerWithExposureLoggingDisabled',
            configName: layerName,
            userPersistedValues: options === null || options === void 0 ? void 0 : options.userPersistedValues,
            persistentAssignmentOptions: options === null || options === void 0 ? void 0 : options.persistentAssignmentOptions
        }));
    };
    /**
     * @deprecated Please use checkGate with CheckGateOptions instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    StatsigServer.prototype.checkGateWithExposureLoggingDisabled = function (user, gateName) {
        return this.getFeatureGateWithExposureLoggingDisabled(user, gateName).value;
    };
    /**
     * @deprecated use getFeatureGate() with CheckGateOptions instead
     */
    StatsigServer.prototype.getFeatureGateWithExposureLoggingDisabled = function (user, gateName) {
        var _this = this;
        return this._errorBoundary.capture(function (ctx) { return _this.getGateImpl(user, gateName, ExposureLogging.Disabled, ctx); }, function () { return (0, FeatureGate_1.makeEmptyFeatureGate)(gateName); }, StatsigContext_1.StatsigContext["new"]({
            caller: 'getFeatureGateWithExposureLoggingDisabled',
            configName: gateName
        }));
    };
    /**
     * @deprecated use getConfig() with GetConfigOptions instead
     */
    StatsigServer.prototype.getConfigWithExposureLoggingDisabled = function (user, configName) {
        var _this = this;
        return this._errorBoundary.capture(function (ctx) {
            return _this.getConfigImpl(user, configName, ExposureLogging.Disabled, ctx);
        }, function () { return new DynamicConfig_1["default"](configName); }, StatsigContext_1.StatsigContext["new"]({
            caller: 'getConfigWithExposureLoggingDisabled',
            configName: configName
        }));
    };
    /**
     * @deprecated use getExperiment() with GetExperimentOptions instead
     * GetExperimentOptions.disableExposureDisabled will be ignored
     */
    StatsigServer.prototype.getExperimentWithExposureLoggingDisabled = function (user, experimentName, options) {
        var _this = this;
        return this._errorBoundary.capture(function (ctx) {
            return _this.getConfigImpl(user, experimentName, ExposureLogging.Disabled, ctx);
        }, function () { return new DynamicConfig_1["default"](experimentName); }, StatsigContext_1.StatsigContext["new"]({
            caller: 'getExperimentWithExposureLoggingDisabled',
            configName: experimentName,
            userPersistedValues: options === null || options === void 0 ? void 0 : options.userPersistedValues,
            persistentAssignmentOptions: options === null || options === void 0 ? void 0 : options.persistentAssignmentOptions
        }));
    };
    /**
     * @deprecated use getLayer() with GetLayerOptions instead
     * GetLayerOptions.disableExposureDisabled will be ignored
     */
    StatsigServer.prototype.getLayerWithExposureLoggingDisabled = function (user, layerName, options) {
        var _this = this;
        return this._errorBoundary.capture(function (ctx) {
            return _this.getLayerImpl(user, layerName, ExposureLogging.Disabled, ctx);
        }, function () { return new Layer_1["default"](layerName); }, StatsigContext_1.StatsigContext["new"]({
            caller: 'getLayerWithExposureLoggingDisabled',
            configName: layerName,
            userPersistedValues: options === null || options === void 0 ? void 0 : options.userPersistedValues,
            persistentAssignmentOptions: options === null || options === void 0 ? void 0 : options.persistentAssignmentOptions
        }));
    };
    //#endregion
    //
    // PRIVATE
    //
    StatsigServer.prototype.logGateExposureImpl = function (user, gateName, evaluation, exposureCause) {
        this._logger.logGateExposure(user, gateName, evaluation, exposureCause === ExposureCause.Manual);
    };
    StatsigServer.prototype.evalGate = function (inputUser, gateName, ctx) {
        var _a = this._validateInputs(inputUser, gateName), error = _a.error, user = _a.normalizedUser;
        if (error) {
            throw error;
        }
        return {
            evaluation: this._evaluator.checkGate(user, gateName, ctx),
            user: user
        };
    };
    StatsigServer.prototype.getGateImpl = function (inputUser, gateName, exposureLogging, ctx) {
        var _a, _b;
        var _c = this.evalGate(inputUser, gateName, ctx), evaluation = _c.evaluation, user = _c.user;
        if (exposureLogging !== ExposureLogging.Disabled) {
            this.logGateExposureImpl(user, gateName, evaluation, ExposureCause.Automatic);
        }
        var gate = (0, FeatureGate_1.makeFeatureGate)(gateName, evaluation.rule_id, evaluation.value === true, evaluation.group_name, evaluation.id_type, (_a = evaluation.evaluation_details) !== null && _a !== void 0 ? _a : null);
        if (((_b = this._options.evaluationCallbacks) === null || _b === void 0 ? void 0 : _b.gateCallback) != null) {
            this._options.evaluationCallbacks.gateCallback(gate, user, this._logger.getGateExposure(user, gateName, evaluation, true));
        }
        return gate;
    };
    StatsigServer.prototype.logConfigExposureImpl = function (user, configName, evaluation, exposureCause) {
        this._logger.logConfigExposure(user, configName, evaluation, exposureCause === ExposureCause.Manual);
    };
    StatsigServer.prototype.evalConfig = function (inputUser, configName, ctx) {
        var _a = this._validateInputs(inputUser, configName), error = _a.error, user = _a.normalizedUser;
        if (error) {
            throw error;
        }
        var evaluation = this._evaluator.getConfig(user, configName, ctx);
        return {
            evaluation: evaluation,
            user: user
        };
    };
    StatsigServer.prototype.getConfigImpl = function (inputUser, configName, exposureLogging, ctx, isExperiment) {
        var _a, _b, _c;
        if (isExperiment === void 0) { isExperiment = false; }
        var _d = this.evalConfig(inputUser, configName, ctx), evaluation = _d.evaluation, user = _d.user;
        var config = new DynamicConfig_1["default"](configName, evaluation.json_value, evaluation.rule_id, evaluation.group_name, evaluation.id_type, evaluation.secondary_exposures, evaluation.rule_id !== ''
            ? this._makeOnDefaultValueFallbackFunction(user)
            : null, (_a = evaluation.evaluation_details) !== null && _a !== void 0 ? _a : null);
        if (exposureLogging !== ExposureLogging.Disabled) {
            this.logConfigExposureImpl(user, configName, evaluation, ExposureCause.Automatic);
        }
        var callback = isExperiment
            ? (_b = this._options.evaluationCallbacks) === null || _b === void 0 ? void 0 : _b.experimentCallback
            : (_c = this._options.evaluationCallbacks) === null || _c === void 0 ? void 0 : _c.dynamicConfigCallback;
        if (callback != null) {
            callback(config, user, this._logger.getConfigExposure(user, configName, evaluation, true));
        }
        return config;
    };
    StatsigServer.prototype.evalLayer = function (inputUser, layerName, ctx) {
        var _a = this._validateInputs(inputUser, layerName), error = _a.error, user = _a.normalizedUser;
        if (error) {
            throw error;
        }
        var evaluation = this._evaluator.getLayer(user, layerName, ctx);
        return {
            evaluation: evaluation,
            user: user
        };
    };
    StatsigServer.prototype.getLayerImpl = function (inputUser, layerName, exposureLogging, ctx) {
        var _this = this;
        var _a;
        var _b = this.evalLayer(inputUser, layerName, ctx), evaluation = _b.evaluation, user = _b.user;
        var logFunc = function (layer, parameterName) {
            var _a;
            if (((_a = _this._options.evaluationCallbacks) === null || _a === void 0 ? void 0 : _a.layerParamCallback) != null) {
                _this._options.evaluationCallbacks.layerParamCallback(layer, parameterName, user, _this._logger.getLayerExposure(user, layerName, parameterName, evaluation, true));
            }
            if (exposureLogging !== ExposureLogging.Disabled) {
                _this.logLayerParameterExposureImpl(user, layerName, parameterName, evaluation, ExposureCause.Automatic);
            }
        };
        var layer = new Layer_1["default"](layerName, evaluation === null || evaluation === void 0 ? void 0 : evaluation.json_value, evaluation === null || evaluation === void 0 ? void 0 : evaluation.rule_id, evaluation === null || evaluation === void 0 ? void 0 : evaluation.group_name, evaluation === null || evaluation === void 0 ? void 0 : evaluation.config_delegate, logFunc, evaluation === null || evaluation === void 0 ? void 0 : evaluation.evaluation_details, evaluation === null || evaluation === void 0 ? void 0 : evaluation.id_type);
        if (((_a = this._options.evaluationCallbacks) === null || _a === void 0 ? void 0 : _a.layerCallback) != null) {
            this._options.evaluationCallbacks.layerCallback(layer, user);
        }
        return layer;
    };
    StatsigServer.prototype.logLayerParameterExposureImpl = function (user, layerName, parameterName, evaluation, exposureCause) {
        if (this._logger == null) {
            return;
        }
        this._logger.logLayerExposure(user, layerName, parameterName, evaluation, exposureCause === ExposureCause.Manual);
    };
    StatsigServer.prototype._validateInputs = function (user, configName) {
        var result = { error: null, normalizedUser: { userID: '' } };
        if (this._ready !== true) {
            result.error = new Errors_1.StatsigUninitializedError();
        }
        else if (typeof configName !== 'string' || configName.length === 0) {
            result.error = new Errors_1.StatsigInvalidArgumentError('Lookup key must be a non-empty string');
        }
        else if (!(0, core_1.isUserIdentifiable)(user)) {
            result.error = new Errors_1.StatsigInvalidArgumentError('Must pass a valid user with a userID or customID for the server SDK to work. See https://docs.statsig.com/messages/serverRequiredUserID/ for more details.');
        }
        else {
            result.normalizedUser = this._normalizeUser(user, this._options);
        }
        this._evaluator.resetSyncTimerIfExited();
        return result;
    };
    StatsigServer.prototype._makeOnDefaultValueFallbackFunction = function (user) {
        var _this = this;
        if (!this._ready) {
            return null;
        }
        return function (config, parameter, defaultValueType, valueType) {
            _this._logger.logConfigDefaultValueFallback(user, "Parameter ".concat(parameter, " is a value of type ").concat(valueType, ".\n      Returning requested defaultValue type ").concat(defaultValueType), {
                name: config.name,
                ruleID: config.getRuleID(),
                parameter: parameter,
                defaultValueType: defaultValueType,
                valueType: valueType
            });
        };
    };
    StatsigServer.prototype._normalizeUser = function (user, options) {
        if (user == null) {
            user = { customIDs: {} }; // Being defensive here
        }
        if ((options === null || options === void 0 ? void 0 : options.environment) != null) {
            user['statsigEnvironment'] = options === null || options === void 0 ? void 0 : options.environment;
        }
        else {
            var storeEnv = this._store.getDefaultEnvironment();
            if (storeEnv != null) {
                user['statsigEnvironment'] = { tier: storeEnv };
            }
        }
        return user;
    };
    return StatsigServer;
}());
exports["default"] = StatsigServer;
