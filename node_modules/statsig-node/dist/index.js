"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.Statsig = exports.StatsigServer = exports.Layer = exports.DataAdapterKeyPath = exports.DynamicConfig = void 0;
var DynamicConfig_1 = __importDefault(require("./DynamicConfig"));
exports.DynamicConfig = DynamicConfig_1["default"];
var Errors_1 = require("./Errors");
var IDataAdapter_1 = require("./interfaces/IDataAdapter");
exports.DataAdapterKeyPath = IDataAdapter_1.DataAdapterKeyPath;
var Layer_1 = __importDefault(require("./Layer"));
exports.Layer = Layer_1["default"];
var OutputLogger_1 = __importDefault(require("./OutputLogger"));
var StatsigInstanceUtils_1 = __importDefault(require("./StatsigInstanceUtils"));
var StatsigServer_1 = __importDefault(require("./StatsigServer"));
exports.StatsigServer = StatsigServer_1["default"];
__exportStar(require("./StatsigOptions"), exports);
// These need to be exported, and we currently export a top level Statsig object
// So in order to not make a breaking change, they must be exported as members of
// that top level object
var EXPORTS = {
    StatsigServer: StatsigServer_1["default"],
    DataAdapterKeyPath: IDataAdapter_1.DataAdapterKeyPath,
    DynamicConfig: DynamicConfig_1["default"],
    Layer: Layer_1["default"],
    StatsigInvalidArgumentError: Errors_1.StatsigInvalidArgumentError,
    StatsigLocalModeNetworkError: Errors_1.StatsigLocalModeNetworkError,
    StatsigTooManyRequestsError: Errors_1.StatsigTooManyRequestsError,
    StatsigUninitializedError: Errors_1.StatsigUninitializedError
};
exports.Statsig = __assign(__assign({}, EXPORTS), { 
    /**
     * Initializes the statsig server SDK.
     * This must be called before checking gates/configs or logging events.
     *
     * @param {string} secretKey - The secret key for this project from the statsig console. Secret keys should be kept secure on the server side, and not used for client-side integrations
     * @param {?StatsigOptions} [options={}] - manual sdk configuration for advanced setup
     * @returns {Promise<void>} - a promise which rejects only if you fail to provide a proper SDK Key
     * @throws Error if a Server Secret Key is not provided
     */
    initialize: function (secretKey, options) {
        var _a;
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var inst, e_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (options.logger) {
                            OutputLogger_1["default"].setLogger(options.logger, secretKey);
                        }
                        inst = (_a = StatsigInstanceUtils_1["default"].getInstance()) !== null && _a !== void 0 ? _a : new StatsigServer_1["default"](secretKey, options);
                        if (StatsigInstanceUtils_1["default"].getInstance() == null) {
                            StatsigInstanceUtils_1["default"].setInstance(inst);
                        }
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, inst.initializeAsync()];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_1 = _b.sent();
                        StatsigInstanceUtils_1["default"].setInstance(null);
                        return [2 /*return*/, Promise.reject(e_1)];
                    case 4: return [2 /*return*/];
                }
            });
        });
    }, 
    /**
     * Gets the boolean result of a gate, evaluated against the given user.
     * An exposure event will automatically be logged for the gate.
     *
     * @param {StatsigUser} user - the user to check this gate value for
     * @param {string} gateName - the name of the gate to check
     * @param {CheckGateOptions} options - the options on how gate should be checkced
     * @returns {boolean} - The value of the gate for the user.  Gates are off (return false) by default
     * @throws Error if initialize() was not called first
     */
    checkGate: function (user, gateName, options) {
        return this._enforceServer().checkGate(user, gateName, options);
    }, getFeatureGate: function (user, gateName, options) {
        return this._enforceServer().getFeatureGate(user, gateName, options);
    }, 
    /**
     * Logs an exposure event for the gate
     *
     * @param {StatsigUser} user - the user to log the exposure against
     * @param {string} gateName - the name of the gate to expose
     */
    manuallyLogGateExposure: function (user, gateName) {
        return this._enforceServer().logGateExposure(user, gateName);
    }, 
    /**
     * Get the values of a dynamic config, evaluated against the given user.
     * An exposure event will automatically be logged for the dynamic config.
     *
     * @param {StatsigUser} user - the user to evaluate for the dyamic config
     * @param {string} configName - the name of the dynamic config to get
     * @param {GetConfigOptions} options - options for config evaluation
     * @returns {DynamicConfig} - the config for the user
     * @throws Error if initialize() was not called first
     */
    getConfig: function (user, configName, options) {
        return this._enforceServer().getConfig(user, configName, options);
    }, 
    /**
     * Logs an exposure event for the dynamic config
     *
     * @param {StatsigUser} user - the user to log the exposure against
     * @param {string} configName - the name of the dynamic config to expose
     */
    manuallyLogConfigExposure: function (user, configName) {
        return this._enforceServer().logConfigExposure(user, configName);
    }, 
    /**
     * Get the values of an experiment, evaluated against the given user.
     * An exposure event will automatically be logged for the experiment.
     *
     * @param {StatsigUser} user - the user to evaluate for the experiment
     * @param {string} experimentName - the name of the experiment to get
     * @param {GetExperimentOptions} options - options for experiment evaluation
     * @returns {DynamicConfig} - the experiment for the user, represented by a Dynamic Config object
     * @throws Error if initialize() was not called first
     */
    getExperiment: function (user, experimentName, options) {
        return this._enforceServer().getExperiment(user, experimentName, options);
    }, 
    /**
     * Get the name of an layer an experiment is in
     * No exposure event will be logged.
     *
     * @param {string} experimentName - the name of the experiment to get
     * @returns {string} - the layer name the experiment belongs to
     * @throws Error if initialize() was not called first
     */
    getExperimentLayer: function (experimentName) {
        return this._enforceServer().getExperimentLayer(experimentName);
    }, 
    /**
     * Logs an exposure event for the experiment.
     *
     * @param {StatsigUser} user - the user to log the exposure against
     * @param {string} experimentName - the name of the experiment to expose
     */
    manuallyLogExperimentExposure: function (user, experimentName) {
        return this._enforceServer().logExperimentExposure(user, experimentName);
    }, 
    /**
     * Get the values of a layer, evaluated against the given user.
     * Exposure events will be fired when get or getValue is called on the resulting Layer class.
     *
     * @param {StatsigUser} user - the user to evaluate for the layer
     * @param {string} layerName - the name of the layer to get
     * @param {GetLayerOptions} options - options for layer evaluation
     * @returns {Layer} - the layer for the user, represented by a Layer
     * @throws Error if initialize() was not called first
     */
    getLayer: function (user, layerName, options) {
        return this._enforceServer().getLayer(user, layerName, options);
    }, 
    /**
     * Logs an exposure event for the parameter in the given layer
     *
     * @param {StatsigUser} user - the user to log the exposure against
     * @param {string} layerName - the name of the layer
     * @param {string} parameterName - the name of the parameter in the layer
     */
    manuallyLogLayerParameterExposure: function (user, layerName, parameterName) {
        this._enforceServer().logLayerParameterExposure(user, layerName, parameterName);
    }, getUserPersistedValues: function (user, idType) {
        return this._enforceServer().getUserPersistedValues(user, idType);
    }, 
    /**
     * Log an event for data analysis and alerting or to measure the impact of an experiment
     *
     * @param {StatsigUser} user - the user associated with this event
     * @param {string} eventName - the name of the event (name = Purchase)
     * @param {string | number | null} value - the value associated with the event (value = 10)
     * @param {Record<string, string> | null} metadata - other attributes associated with this event (metadata = {item_name: 'banana', currency: 'USD'})
     * @throws Error if initialize() was not called first
     */
    logEvent: function (user, eventName, value, metadata) {
        if (value === void 0) { value = null; }
        if (metadata === void 0) { metadata = null; }
        this._enforceServer().logEvent(user, eventName, value, metadata);
    }, 
    /**
     * Log an event for data analysis and alerting or to measure the impact of an experiment
     *
     * @param {LogEventObject} eventObject - an object containing the event data
     */
    logEventObject: function (eventObject) {
        this._enforceServer().logEventObject(eventObject);
    }, 
    /**
     * Informs the statsig SDK that the client is closing or shutting down
     * so the SDK can clean up internal stat
     * @param timeout the timeout in milliseconds to wait for pending promises to resolve
     */
    shutdown: function (timeout) {
        this._enforceServer().shutdown(timeout);
        OutputLogger_1["default"].resetLogger();
    }, 
    /**
     * Informs the statsig SDK that the server is closing or shutting down
     * so the SDK can clean up internal state
     * Ensures any pending promises are resolved and remaining events are flushed.
     * @param timeout the timeout in milliseconds to wait for pending promises to resolve
     */
    shutdownAsync: function (timeout) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._enforceServer().shutdownAsync(timeout)];
                    case 1:
                        _a.sent();
                        OutputLogger_1["default"].resetLogger();
                        return [2 /*return*/];
                }
            });
        });
    }, 
    /**
     * Returns the initialize values for the given user
     * Can be used to bootstrap a client SDK with up to date values
     * @param user the user to evaluate configurations for
     * @param clientSDKKey the client SDK key to use for fetching configs
     */
    getClientInitializeResponse: function (user, clientSDKKey, options) {
        return this._enforceServer().getClientInitializeResponse(user, clientSDKKey, options);
    }, 
    /**
     * Overrides the given gate with the provided value
     * If no userID is provided, it will override for all users
     * If a userID is provided, it will override the gate with the given value for that user only
     */
    overrideGate: function (gateName, value, userID) {
        if (userID === void 0) { userID = ''; }
        this._enforceServer().overrideGate(gateName, value, userID);
    }, 
    /**
     * Overrides the given config or experiment with the provided value
     * If no userID is provided, it will override for all users
     * If a userID is provided, it will override the config/experiment with the given value for that user only
     */
    overrideConfig: function (configName, value, userID) {
        if (userID === void 0) { userID = ''; }
        this._enforceServer().overrideConfig(configName, value, userID);
    }, 
    /**
     * Overrides the given layer with the provided value
     * If no userID is provided, it will override for all users
     * If a userID is provided, it will override the layer with the given value for that user only
     */
    overrideLayer: function (layerName, value, userID) {
        if (userID === void 0) { userID = ''; }
        this._enforceServer().overrideLayer(layerName, value, userID);
    }, 
    /**
     * Flushes all the events that are currently in the queue to Statsig.
     */
    flush: function (timeout) {
        var inst = StatsigInstanceUtils_1["default"].getInstance();
        if (inst == null) {
            return Promise.resolve();
        }
        return inst.flush(timeout);
    }, 
    /**
     * Clears all gate overrides
     */
    clearAllGateOverrides: function () {
        this._enforceServer().clearAllGateOverrides();
    }, 
    /**
     * Clears all config overrides
     */
    clearAllConfigOverrides: function () {
        this._enforceServer().clearAllConfigOverrides();
    }, 
    /**
     * Clears all layer overrides
     */
    clearAllLayerOverrides: function () {
        this._enforceServer().clearAllLayerOverrides();
    }, 
    /**
     * Gets all Feature Gate names
     *
     * @returns {string[]}
     */
    getFeatureGateList: function () {
        return this._enforceServer().getFeatureGateList();
    }, 
    /**
     * Gets all Dynamic Config names
     *
     * @returns {string[]}
     */
    getDynamicConfigList: function () {
        return this._enforceServer().getDynamicConfigList();
    }, 
    /**
     * Gets all Experiment names
     *
     * @returns {string[]}
     */
    getExperimentList: function () {
        return this._enforceServer().getExperimentList();
    }, 
    /**
     * Gets all Autotune names
     *
     * @returns {string[]}
     */
    getAutotuneList: function () {
        return this._enforceServer().getAutotuneList();
    }, 
    /**
     * Gets all Layer names
     *
     * @returns {string[]}
     */
    getLayerList: function () {
        return this._enforceServer().getLayerList();
    }, syncConfigSpecs: function () {
        return this._enforceServer().syncStoreSpecs();
    }, syncIdLists: function () {
        return this._enforceServer().syncStoreIdLists();
    }, 
    //#region Deprecated _sync and _withExposureDisabled Methods
    /**
     * @deprecated Please use checkGateSync instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    checkGateSync: function (user, gateName) {
        return this._enforceServer().checkGateSync(user, gateName);
    }, 
    /**
     * @deprecated Please use getFeatureGate instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    getFeatureGateSync: function (user, gateName) {
        return this._enforceServer().getFeatureGateSync(user, gateName);
    }, 
    /**
     * @deprecated Please use checkGate() with CheckGateOptions instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    checkGateWithExposureLoggingDisabledSync: function (user, gateName) {
        return this._enforceServer().checkGateWithExposureLoggingDisabledSync(user, gateName);
    }, 
    /**
     * @deprecated Please use getConfig instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    getConfigSync: function (user, configName) {
        return this._enforceServer().getConfigSync(user, configName);
    }, 
    /**
     * @deprecated Please use getConfig() with GetConfigOptions instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    getConfigWithExposureLoggingDisabledSync: function (user, configName) {
        return this._enforceServer().getConfigWithExposureLoggingDisabledSync(user, configName);
    }, 
    /**
     * @deprecated Please use getExperiment instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    getExperimentSync: function (user, experimentName, options) {
        return this._enforceServer().getExperimentSync(user, experimentName, options);
    }, 
    /**
     * @deprecated Please use getExperiment() with GetExperimentOptions instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    getExperimentWithExposureLoggingDisabledSync: function (user, experimentName, options) {
        return this._enforceServer().getExperimentWithExposureLoggingDisabledSync(user, experimentName, options);
    }, 
    /**
     * @deprecated Please use getLayer instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    getLayerSync: function (user, layerName, options) {
        return this._enforceServer().getLayerSync(user, layerName, options);
    }, 
    /**
     * @deprecated Please use getLayer with GetLayerOptions instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    getLayerWithExposureLoggingDisabledSync: function (user, layerName, options) {
        return this._enforceServer().getLayerWithExposureLoggingDisabledSync(user, layerName, options);
    }, 
    /**
     * @deprecated Please use checkGate with CheckGateOptions instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    checkGateWithExposureLoggingDisabled: function (user, gateName) {
        return this._enforceServer().checkGateWithExposureLoggingDisabled(user, gateName);
    }, 
    /**
     * @deprecated Please use getFeatureGate with CheckGateOptions instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    getFeatureGateWithExposureLoggingDisabled: function (user, gateName) {
        return this._enforceServer().getFeatureGateWithExposureLoggingDisabled(user, gateName);
    }, 
    /**
     * @deprecated Please use getExperiment with GetExperimentOptions instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    getExperimentWithExposureLoggingDisabled: function (user, experimentName, options) {
        return this._enforceServer().getExperimentWithExposureLoggingDisabled(user, experimentName, options);
    }, 
    /**
     * @deprecated Please use getConfig with GetConfigOptions instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    getConfigWithExposureLoggingDisabled: function (user, configName) {
        return this._enforceServer().getConfigWithExposureLoggingDisabled(user, configName);
    }, 
    /**
     * @deprecated Please use getLayer with GetLayerOptions instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    getLayerWithExposureLoggingDisabled: function (user, layerName, options) {
        return this._enforceServer().getLayerWithExposureLoggingDisabled(user, layerName, options);
    }, _enforceServer: function () {
        var instance = StatsigInstanceUtils_1["default"].getInstance();
        if (instance == null) {
            throw new Errors_1.StatsigUninitializedError();
        }
        return instance;
    } });
exports["default"] = exports.Statsig;
module.exports = __assign({ "default": exports.Statsig }, exports.Statsig);
