"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var ConfigSpec_1 = require("./ConfigSpec");
var Diagnostics_1 = __importDefault(require("./Diagnostics"));
var Errors_1 = require("./Errors");
var IDataAdapter_1 = require("./interfaces/IDataAdapter");
var OutputLogger_1 = __importDefault(require("./OutputLogger"));
var SDKFlags_1 = __importDefault(require("./SDKFlags"));
var core_1 = require("./utils/core");
var Hashing_1 = require("./utils/Hashing");
var IDListUtil_1 = __importDefault(require("./utils/IDListUtil"));
var safeFetch_1 = __importDefault(require("./utils/safeFetch"));
var SYNC_OUTDATED_MAX = 120 * 1000;
var SpecStore = /** @class */ (function () {
    function SpecStore(secretKey, fetcher, options) {
        var _a, _b;
        this.rulesetsSyncTimerLastActiveTime = Date.now();
        this.idListsSyncTimerLastActiveTime = Date.now();
        this.rulesetsSyncPromise = function () { return Promise.resolve(); };
        this.idListsSyncPromise = function () { return Promise.resolve(); };
        this.rulesetsSyncFailureCount = 0;
        this.idListsSyncFailureCount = 0;
        this.getIDListCallCount = 0;
        this.clientSDKKeyToAppMap = {};
        this.hashedClientSDKKeyToAppMap = {};
        this.hashedSDKKeysToEntities = {};
        this.fetcher = fetcher;
        this.rulesUpdatedCallback = (_a = options.rulesUpdatedCallback) !== null && _a !== void 0 ? _a : null;
        this.lastUpdateTime = 0;
        this.initialUpdateTime = 0;
        this.store = {
            gates: {},
            configs: {},
            idLists: {},
            layers: {},
            experimentToLayer: {}
        };
        this.networkOverrideFunc = (_b = options.networkOverrideFunc) !== null && _b !== void 0 ? _b : null;
        this.hashedSDKKey =
            secretKey != null ? (0, Hashing_1.sha256HashBase64)(secretKey) : 'undefined';
        this.rulesetsSyncInterval = options.rulesetsSyncIntervalMs;
        this.idListsSyncInterval = options.idListsSyncIntervalMs;
        this.disableRulesetsSync = options.disableRulesetsSync;
        this.disableIdListsSync = options.disableIdListsSync;
        this.initialized = false;
        this.rulesetsSyncTimer = null;
        this.idListsSyncTimer = null;
        this.dataAdapter = options.dataAdapter;
        this.initReason = 'Uninitialized';
        this.bootstrapValues = options.bootstrapValues;
        this.initStrategyForIDLists = options.initStrategyForIDLists;
        this.clientSDKKeyToAppMap = {};
        this.hashedClientSDKKeyToAppMap = {};
        this.primaryTargetAppID = null;
        this.defaultEnvironemnt = null;
        this.sessionReplayInfo = null;
    }
    SpecStore.prototype.getInitReason = function () {
        return this.initReason;
    };
    SpecStore.prototype.getInitialUpdateTime = function () {
        return this.initialUpdateTime;
    };
    SpecStore.prototype.getLastUpdateTime = function () {
        return this.lastUpdateTime;
    };
    SpecStore.prototype.getGate = function (gateName) {
        var _a;
        return (_a = this.store.gates[gateName]) !== null && _a !== void 0 ? _a : null;
    };
    SpecStore.prototype.getConfig = function (configName) {
        var _a;
        return (_a = this.store.configs[configName]) !== null && _a !== void 0 ? _a : null;
    };
    SpecStore.prototype.getLayer = function (layerName) {
        var _a;
        return (_a = this.store.layers[layerName]) !== null && _a !== void 0 ? _a : null;
    };
    SpecStore.prototype.getExperimentLayer = function (experimentName) {
        var _a;
        return (_a = this.store.experimentToLayer[experimentName]) !== null && _a !== void 0 ? _a : null;
    };
    SpecStore.prototype.getIDList = function (listName) {
        var _a;
        return (_a = this.store.idLists[listName]) !== null && _a !== void 0 ? _a : null;
    };
    SpecStore.prototype.getAllGates = function () {
        return this.store.gates;
    };
    SpecStore.prototype.getAllConfigs = function () {
        return this.store.configs;
    };
    SpecStore.prototype.getAllLayers = function () {
        return this.store.layers;
    };
    SpecStore.prototype.getClientKeyToAppMap = function () {
        return this.clientSDKKeyToAppMap;
    };
    SpecStore.prototype.getHashedClientKeyToAppMap = function () {
        return this.hashedClientSDKKeyToAppMap;
    };
    SpecStore.prototype.getHashedSDKKeysToEntities = function () {
        return this.hashedSDKKeysToEntities;
    };
    SpecStore.prototype.getPrimaryTargetAppID = function () {
        return this.primaryTargetAppID;
    };
    SpecStore.prototype.getDefaultEnvironment = function () {
        return this.defaultEnvironemnt;
    };
    SpecStore.prototype.getSessionReplayInfo = function () {
        return this.sessionReplayInfo;
    };
    SpecStore.prototype.init = function (ctx) {
        return __awaiter(this, void 0, void 0, function () {
            var specsJSON, _a, synced, error, error, _b, synced, error, err;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        specsJSON = null;
                        if (!this.dataAdapter) return [3 /*break*/, 3];
                        if (this.bootstrapValues != null) {
                            OutputLogger_1["default"].info('statsigSDK::initialize> Conflict between bootstrap and adapter. Defaulting to adapter.');
                        }
                        return [4 /*yield*/, this.dataAdapter.initialize()];
                    case 1:
                        _c.sent();
                        return [4 /*yield*/, this._fetchConfigSpecsFromAdapter()];
                    case 2:
                        _a = _c.sent(), synced = _a.synced, error = _a.error;
                        if (synced) {
                            ctx.setSuccess('DataAdapter');
                        }
                        if (error) {
                            ctx.setFailed(error);
                        }
                        _c.label = 3;
                    case 3:
                        if (this.initReason === 'Uninitialized' && this.bootstrapValues != null) {
                            try {
                                Diagnostics_1["default"].mark.bootstrap.process.start({});
                                specsJSON = JSON.parse(this.bootstrapValues);
                                this._process(specsJSON);
                                if (this.lastUpdateTime !== 0) {
                                    this.initReason = 'Bootstrap';
                                    ctx.setSuccess('Bootstrap');
                                }
                            }
                            catch (_d) {
                                error = new Errors_1.StatsigInvalidBootstrapValuesError();
                                OutputLogger_1["default"].error(error);
                                ctx.setFailed(error);
                            }
                            Diagnostics_1["default"].mark.bootstrap.process.end({
                                success: this.initReason === 'Bootstrap'
                            });
                        }
                        if (!(this.initReason === 'Uninitialized')) return [3 /*break*/, 5];
                        return [4 /*yield*/, this._fetchConfigSpecsFromServer()];
                    case 4:
                        _b = _c.sent(), synced = _b.synced, error = _b.error;
                        if (synced) {
                            ctx.setSuccess('Network');
                        }
                        if (error) {
                            err = new Errors_1.StatsigInitializeFromNetworkError(error);
                            OutputLogger_1["default"].error(err);
                            ctx.setFailed(err);
                        }
                        _c.label = 5;
                    case 5:
                        this.setInitialUpdateTime();
                        if (!(this.initStrategyForIDLists === 'lazy')) return [3 /*break*/, 6];
                        setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, this._initIDLists()];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        }); }, 0);
                        return [3 /*break*/, 8];
                    case 6:
                        if (!(this.initStrategyForIDLists !== 'none')) return [3 /*break*/, 8];
                        return [4 /*yield*/, this._initIDLists()];
                    case 7:
                        _c.sent();
                        _c.label = 8;
                    case 8:
                        this.pollForUpdates();
                        this.initialized = true;
                        return [2 /*return*/];
                }
            });
        });
    };
    SpecStore.prototype._initIDLists = function () {
        return __awaiter(this, void 0, void 0, function () {
            var error, _a, error_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.dataAdapter) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.syncIdListsFromDataAdapter()];
                    case 1:
                        _a = _b.sent();
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, this.syncIdListsFromNetwork()];
                    case 3:
                        _a = _b.sent();
                        _b.label = 4;
                    case 4:
                        error = (_a).error;
                        if (!error) return [3 /*break*/, 7];
                        if (!this.dataAdapter) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.syncIdListsFromNetwork()];
                    case 5:
                        error_1 = (_b.sent()).error;
                        if (error_1) {
                            OutputLogger_1["default"].error(new Errors_1.StatsigInitializeIDListsError(error_1));
                        }
                        return [3 /*break*/, 7];
                    case 6:
                        OutputLogger_1["default"].error(new Errors_1.StatsigInitializeIDListsError(error));
                        _b.label = 7;
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    SpecStore.prototype.resetSyncTimerIfExited = function () {
        var rulesetsSyncTimerInactive = this.rulesetsSyncTimerLastActiveTime <
            Date.now() - Math.max(SYNC_OUTDATED_MAX, this.rulesetsSyncInterval);
        var idListsSyncTimerInactive = this.idListsSyncTimerLastActiveTime <
            Date.now() - Math.max(SYNC_OUTDATED_MAX, this.idListsSyncInterval);
        if ((!rulesetsSyncTimerInactive || this.disableRulesetsSync) &&
            (!idListsSyncTimerInactive || this.disableIdListsSync)) {
            return null;
        }
        var message = '';
        if (rulesetsSyncTimerInactive && !this.disableRulesetsSync) {
            this.clearRulesetsSyncTimer();
            message = message.concat("Force reset sync timer. Last update time: ".concat(this.rulesetsSyncTimerLastActiveTime, ", now: ").concat(Date.now()));
        }
        if (idListsSyncTimerInactive && !this.disableIdListsSync) {
            this.clearIdListsSyncTimer();
            message = message.concat("Force reset id list sync timer. Last update time: ".concat(this.idListsSyncTimerLastActiveTime, ", now: ").concat(Date.now()));
        }
        this.pollForUpdates();
        return new Error(message);
    };
    SpecStore.prototype.isServingChecks = function () {
        return this.lastUpdateTime !== 0;
    };
    SpecStore.prototype._fetchConfigSpecsFromServer = function () {
        return __awaiter(this, void 0, void 0, function () {
            var response, specsString, _a, success, hasUpdates, e_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 5, , 6]);
                        response = undefined;
                        return [4 /*yield*/, this.fetcher.downloadConfigSpecs(this.lastUpdateTime)];
                    case 1:
                        response = _b.sent();
                        Diagnostics_1["default"].mark.downloadConfigSpecs.process.start({});
                        return [4 /*yield*/, response.text()];
                    case 2:
                        specsString = _b.sent();
                        _a = this._process(JSON.parse(specsString)), success = _a.success, hasUpdates = _a.hasUpdates;
                        if (!success) {
                            return [2 /*return*/, {
                                    synced: false,
                                    error: new Errors_1.StatsigInvalidConfigSpecsResponseError()
                                }];
                        }
                        this.initReason = 'Network';
                        if (this.rulesUpdatedCallback != null &&
                            typeof this.rulesUpdatedCallback === 'function') {
                            this.rulesUpdatedCallback(specsString, this.lastUpdateTime);
                        }
                        if (!hasUpdates) return [3 /*break*/, 4];
                        return [4 /*yield*/, this._saveConfigSpecsToAdapter(specsString)];
                    case 3:
                        _b.sent();
                        Diagnostics_1["default"].mark.downloadConfigSpecs.process.end({
                            success: this.initReason === 'Network'
                        });
                        _b.label = 4;
                    case 4: return [2 /*return*/, { synced: true }];
                    case 5:
                        e_1 = _b.sent();
                        if (e_1 instanceof Errors_1.StatsigLocalModeNetworkError) {
                            return [2 /*return*/, { synced: false }];
                        }
                        else {
                            return [2 /*return*/, { synced: false, error: e_1 }];
                        }
                        return [3 /*break*/, 6];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    SpecStore.prototype._fetchConfigSpecsFromAdapter = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, result, error, configSpecs, success, e_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        if (!this.dataAdapter) {
                            return [2 /*return*/, { synced: false }];
                        }
                        return [4 /*yield*/, this.dataAdapter.get((0, IDataAdapter_1.getDataAdapterKey)(this.hashedSDKKey, IDataAdapter_1.DataAdapterKeyPath.V1Rulesets))];
                    case 1:
                        _a = _b.sent(), result = _a.result, error = _a.error;
                        if (result && !error) {
                            configSpecs = typeof result === 'string' ? JSON.parse(result) : result;
                            success = this._process(configSpecs).success;
                            if (success) {
                                this.initReason = 'DataAdapter';
                                return [2 /*return*/, { synced: true }];
                            }
                        }
                        return [2 /*return*/, {
                                synced: false,
                                error: new Errors_1.StatsigInvalidDataAdapterValuesError(IDataAdapter_1.DataAdapterKeyPath.V1Rulesets)
                            }];
                    case 2:
                        e_2 = _b.sent();
                        return [2 /*return*/, { synced: false, error: e_2 }];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    SpecStore.prototype._saveConfigSpecsToAdapter = function (specString) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.dataAdapter) {
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, this.dataAdapter.set((0, IDataAdapter_1.getDataAdapterKey)(this.hashedSDKKey, IDataAdapter_1.DataAdapterKeyPath.V1Rulesets), specString, this.lastUpdateTime)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    SpecStore.prototype.pollForUpdates = function () {
        var _this = this;
        if (this.rulesetsSyncTimer == null && !this.disableRulesetsSync) {
            this.rulesetsSyncTimerLastActiveTime = Date.now();
            this.rulesetsSyncPromise = function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.rulesetsSyncTimerLastActiveTime = Date.now();
                            return [4 /*yield*/, this.syncConfigSpecs()];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); };
            this.rulesetsSyncTimer = (0, core_1.poll)(this.rulesetsSyncPromise, this.rulesetsSyncInterval);
        }
        if (this.idListsSyncTimer == null && !this.disableIdListsSync) {
            this.idListsSyncTimerLastActiveTime = Date.now();
            this.idListsSyncPromise = function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.idListsSyncTimerLastActiveTime = Date.now();
                            return [4 /*yield*/, this.syncIdLists()];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); };
            this.idListsSyncTimer = (0, core_1.poll)(this.idListsSyncPromise, this.idListsSyncInterval);
        }
    };
    SpecStore.prototype.logDiagnostics = function (context, type) {
        if (!this.initialized) {
            return;
        }
        switch (context) {
            case 'config_sync':
                Diagnostics_1["default"].logDiagnostics('config_sync', {
                    type: type
                });
                break;
            case 'initialize':
                Diagnostics_1["default"].logDiagnostics('initialize', {
                    type: 'initialize'
                });
                break;
        }
    };
    SpecStore.prototype.syncConfigSpecs = function () {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var adapter, shouldSyncFromAdapter, _b, synced, error, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        adapter = this.dataAdapter;
                        shouldSyncFromAdapter = ((_a = adapter === null || adapter === void 0 ? void 0 : adapter.supportsPollingUpdatesFor) === null || _a === void 0 ? void 0 : _a.call(adapter, IDataAdapter_1.DataAdapterKeyPath.V1Rulesets)) ===
                            true;
                        if (!shouldSyncFromAdapter) return [3 /*break*/, 2];
                        return [4 /*yield*/, this._fetchConfigSpecsFromAdapter()];
                    case 1:
                        _c = _d.sent();
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, this._fetchConfigSpecsFromServer()];
                    case 3:
                        _c = _d.sent();
                        _d.label = 4;
                    case 4:
                        _b = _c, synced = _b.synced, error = _b.error;
                        if (synced) {
                            this.rulesetsSyncFailureCount = 0;
                        }
                        else if (error) {
                            OutputLogger_1["default"].debug(error);
                            this.rulesetsSyncFailureCount++;
                            if (this.rulesetsSyncFailureCount * this.rulesetsSyncInterval >
                                SYNC_OUTDATED_MAX) {
                                OutputLogger_1["default"].warn("statsigSDK::sync> Syncing the server SDK from the \n          ".concat(shouldSyncFromAdapter ? 'data adapter' : 'network', "\n           has failed for  \n           ").concat(this.rulesetsSyncFailureCount * this.rulesetsSyncInterval, "\n          ms. Your sdk will continue to serve gate/config/experiment definitions as of the last successful sync. See https://docs.statsig.com/messages/serverSDKConnection for more information"));
                                this.rulesetsSyncFailureCount = 0;
                            }
                        }
                        this.logDiagnostics('config_sync', 'config_spec');
                        return [2 /*return*/];
                }
            });
        });
    };
    SpecStore.prototype.syncIdLists = function () {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var adapter, shouldSyncFromAdapter, result, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (this.initStrategyForIDLists === 'none') {
                            return [2 /*return*/];
                        }
                        adapter = this.dataAdapter;
                        shouldSyncFromAdapter = ((_a = adapter === null || adapter === void 0 ? void 0 : adapter.supportsPollingUpdatesFor) === null || _a === void 0 ? void 0 : _a.call(adapter, IDataAdapter_1.DataAdapterKeyPath.V1IDLists)) ===
                            true;
                        if (!shouldSyncFromAdapter) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.syncIdListsFromDataAdapter()];
                    case 1:
                        _b = _c.sent();
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, this.syncIdListsFromNetwork()];
                    case 3:
                        _b = _c.sent();
                        _c.label = 4;
                    case 4:
                        result = _b;
                        if (!(shouldSyncFromAdapter && result.error)) return [3 /*break*/, 6];
                        OutputLogger_1["default"].debug(result.error);
                        OutputLogger_1["default"].debug('Failed to sync ID lists with data adapter. Retrying with network');
                        return [4 /*yield*/, this.syncIdListsFromNetwork()];
                    case 5:
                        result = _c.sent();
                        _c.label = 6;
                    case 6:
                        if (result.synced) {
                            this.idListsSyncFailureCount = 0;
                        }
                        else if (result.error) {
                            OutputLogger_1["default"].debug(result.error);
                            this.idListsSyncFailureCount++;
                            if (this.idListsSyncFailureCount * this.idListsSyncInterval >
                                SYNC_OUTDATED_MAX) {
                                OutputLogger_1["default"].warn("statsigSDK::sync> Syncing ID lists from the \n          ".concat(shouldSyncFromAdapter ? 'data adapter' : 'network', " \n          has failed for  ").concat(this.idListsSyncFailureCount * this.idListsSyncInterval, "\n          ms. The SDK will continue to serve gate/config/experiment definitions that depend on ID lists as of the last successful sync. See https://docs.statsig.com/messages/serverSDKConnection for more information"));
                                this.idListsSyncFailureCount = 0;
                            }
                        }
                        this.logDiagnostics('config_sync', 'id_list');
                        return [2 /*return*/];
                }
            });
        });
    };
    // returns a boolean indicating whether specsJSON has was successfully parsed
    SpecStore.prototype._process = function (specsJSON) {
        var _a, _b, _c, _d, _e, _f, _g;
        var hashedSDKKeyUsed = specsJSON.hashed_sdk_key_used;
        if (hashedSDKKeyUsed != null && typeof hashedSDKKeyUsed === 'string') {
            if (!this.fetcher.validateSDKKeyUsed(hashedSDKKeyUsed)) {
                return { success: false, hasUpdates: true };
            }
        }
        if (!(specsJSON === null || specsJSON === void 0 ? void 0 : specsJSON.has_updates)) {
            return { success: true, hasUpdates: false };
        }
        if ((specsJSON === null || specsJSON === void 0 ? void 0 : specsJSON.time) !== undefined &&
            specsJSON.time < this.lastUpdateTime) {
            return { success: true, hasUpdates: true };
        }
        var updatedGates = {};
        var updatedConfigs = {};
        var updatedLayers = {};
        var gateArray = specsJSON === null || specsJSON === void 0 ? void 0 : specsJSON.feature_gates;
        var configArray = specsJSON === null || specsJSON === void 0 ? void 0 : specsJSON.dynamic_configs;
        var layersArray = specsJSON === null || specsJSON === void 0 ? void 0 : specsJSON.layer_configs;
        var layerToExperimentMap = specsJSON === null || specsJSON === void 0 ? void 0 : specsJSON.layers;
        var samplingRates = specsJSON === null || specsJSON === void 0 ? void 0 : specsJSON.diagnostics;
        Diagnostics_1["default"].instance.setSamplingRate(samplingRates);
        if (!Array.isArray(gateArray) ||
            !Array.isArray(configArray) ||
            !Array.isArray(layersArray)) {
            return { success: false, hasUpdates: true };
        }
        for (var _i = 0, gateArray_1 = gateArray; _i < gateArray_1.length; _i++) {
            var gateJSON = gateArray_1[_i];
            try {
                var gate = new ConfigSpec_1.ConfigSpec(gateJSON);
                updatedGates[gate.name] = gate;
            }
            catch (e) {
                return { success: false, hasUpdates: true };
            }
        }
        for (var _h = 0, configArray_1 = configArray; _h < configArray_1.length; _h++) {
            var configJSON = configArray_1[_h];
            try {
                var config = new ConfigSpec_1.ConfigSpec(configJSON);
                updatedConfigs[config.name] = config;
            }
            catch (e) {
                return { success: false, hasUpdates: true };
            }
        }
        for (var _j = 0, layersArray_1 = layersArray; _j < layersArray_1.length; _j++) {
            var layerJSON = layersArray_1[_j];
            try {
                var config = new ConfigSpec_1.ConfigSpec(layerJSON);
                updatedLayers[config.name] = config;
            }
            catch (e) {
                return { success: false, hasUpdates: true };
            }
        }
        SDKFlags_1["default"].setFlags(specsJSON === null || specsJSON === void 0 ? void 0 : specsJSON.sdk_flags);
        var updatedExpToLayer = this._reverseLayerExperimentMapping(layerToExperimentMap);
        this.store.gates = updatedGates;
        this.store.configs = updatedConfigs;
        this.store.layers = updatedLayers;
        this.store.experimentToLayer = updatedExpToLayer;
        this.lastUpdateTime = (_a = specsJSON.time) !== null && _a !== void 0 ? _a : this.lastUpdateTime;
        this.clientSDKKeyToAppMap = ((_b = specsJSON === null || specsJSON === void 0 ? void 0 : specsJSON.sdk_keys_to_app_ids) !== null && _b !== void 0 ? _b : {});
        this.hashedClientSDKKeyToAppMap = ((_c = specsJSON === null || specsJSON === void 0 ? void 0 : specsJSON.hashed_sdk_keys_to_app_ids) !== null && _c !== void 0 ? _c : {});
        this.hashedSDKKeysToEntities = ((_d = specsJSON === null || specsJSON === void 0 ? void 0 : specsJSON.hashed_sdk_keys_to_entities) !== null && _d !== void 0 ? _d : {});
        this.primaryTargetAppID = ((_e = specsJSON === null || specsJSON === void 0 ? void 0 : specsJSON.app_id) !== null && _e !== void 0 ? _e : null);
        this.defaultEnvironemnt = ((_f = specsJSON === null || specsJSON === void 0 ? void 0 : specsJSON.default_environment) !== null && _f !== void 0 ? _f : null);
        this.sessionReplayInfo = ((_g = specsJSON === null || specsJSON === void 0 ? void 0 : specsJSON.session_replay_info) !== null && _g !== void 0 ? _g : null);
        return { success: true, hasUpdates: true };
    };
    /**
     * Returns a reverse mapping of layers to experiment (or vice versa)
     */
    SpecStore.prototype._reverseLayerExperimentMapping = function (layersMapping) {
        var reverseMapping = {};
        if (layersMapping != null && typeof layersMapping === 'object') {
            for (var _i = 0, _a = Object.entries(layersMapping); _i < _a.length; _i++) {
                var _b = _a[_i], layerName = _b[0], experiments = _b[1];
                for (var _c = 0, experiments_1 = experiments; _c < experiments_1.length; _c++) {
                    var experimentName = experiments_1[_c];
                    // experiment -> layer is a 1:1 mapping
                    reverseMapping[experimentName] = layerName;
                }
            }
        }
        return reverseMapping;
    };
    SpecStore.prototype.syncIdListsFromDataAdapter = function () {
        return __awaiter(this, void 0, void 0, function () {
            var dataAdapter_1, adapterIdLists, lookup, tasks, _loop_1, _i, lookup_1, name_1, e_3;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 3, , 4]);
                        dataAdapter_1 = this.dataAdapter;
                        if (!dataAdapter_1) {
                            return [2 /*return*/, { synced: false }];
                        }
                        return [4 /*yield*/, dataAdapter_1.get((0, IDataAdapter_1.getDataAdapterKey)(this.hashedSDKKey, IDataAdapter_1.DataAdapterKeyPath.V1IDLists))];
                    case 1:
                        adapterIdLists = (_a.sent()).result;
                        if (!adapterIdLists) {
                            return [2 /*return*/, {
                                    synced: false,
                                    error: new Errors_1.StatsigInvalidDataAdapterValuesError(IDataAdapter_1.DataAdapterKeyPath.V1IDLists)
                                }];
                        }
                        lookup = IDListUtil_1["default"].parseBootstrapLookup(adapterIdLists);
                        if (!lookup) {
                            return [2 /*return*/, {
                                    synced: false,
                                    error: new Errors_1.StatsigInvalidDataAdapterValuesError(IDataAdapter_1.DataAdapterKeyPath.V1IDLists)
                                }];
                        }
                        tasks = [];
                        _loop_1 = function (name_1) {
                            tasks.push(new Promise(function (resolve, reject) {
                                dataAdapter_1
                                    .get((0, IDataAdapter_1.getDataAdapterKey)(_this.hashedSDKKey, IDataAdapter_1.DataAdapterKeyPath.IDList, IDataAdapter_1.CompressFormat.PlainText, name_1))
                                    .then(function (_a) {
                                    var data = _a.result;
                                    if (!data || typeof data !== 'string') {
                                        return reject(new Errors_1.StatsigInvalidDataAdapterValuesError(IDataAdapter_1.DataAdapterKeyPath.V1Rulesets));
                                    }
                                    _this.store.idLists[name_1] = {
                                        ids: {},
                                        readBytes: 0,
                                        url: 'bootstrap',
                                        fileID: 'bootstrap',
                                        creationTime: 0
                                    };
                                    IDListUtil_1["default"].updateIdList(_this.store.idLists, name_1, data);
                                })["catch"](function (e) {
                                    OutputLogger_1["default"].debug(e);
                                })["finally"](function () { return resolve(); });
                            }));
                        };
                        for (_i = 0, lookup_1 = lookup; _i < lookup_1.length; _i++) {
                            name_1 = lookup_1[_i];
                            _loop_1(name_1);
                        }
                        return [4 /*yield*/, Promise.all(tasks)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, { synced: true }];
                    case 3:
                        e_3 = _a.sent();
                        return [2 /*return*/, { synced: false, error: e_3 }];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    SpecStore.prototype.syncIdListsFromNetwork = function () {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function () {
            var response, e_4, error, json, lookup, promises, _i, _f, _g, name_2, item, url, fileID, newCreationTime, oldCreationTime, newFile, fileSize, readSize, e_5;
            return __generator(this, function (_h) {
                switch (_h.label) {
                    case 0:
                        response = null;
                        _h.label = 1;
                    case 1:
                        _h.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.fetcher.getIDLists()];
                    case 2:
                        response = _h.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_4 = _h.sent();
                        if (e_4 instanceof Errors_1.StatsigLocalModeNetworkError) {
                            return [2 /*return*/, { synced: false }];
                        }
                        else {
                            return [2 /*return*/, { synced: false, error: e_4 }];
                        }
                        return [3 /*break*/, 4];
                    case 4:
                        if (!response) {
                            return [2 /*return*/, { synced: false }];
                        }
                        _h.label = 5;
                    case 5:
                        _h.trys.push([5, 10, 11, 12]);
                        return [4 /*yield*/, response.json()];
                    case 6:
                        json = _h.sent();
                        lookup = IDListUtil_1["default"].parseLookupResponse(json);
                        if (!lookup) {
                            return [2 /*return*/, {
                                    synced: false,
                                    error: new Errors_1.StatsigInvalidIDListsResponseError()
                                }];
                        }
                        Diagnostics_1["default"].mark.getIDListSources.process.start({
                            idListCount: Object.keys(lookup).length
                        });
                        promises = [];
                        for (_i = 0, _f = Object.entries(lookup); _i < _f.length; _i++) {
                            _g = _f[_i], name_2 = _g[0], item = _g[1];
                            url = item.url;
                            fileID = item.fileID;
                            newCreationTime = item.creationTime;
                            oldCreationTime = (_b = (_a = this.store.idLists[name_2]) === null || _a === void 0 ? void 0 : _a.creationTime) !== null && _b !== void 0 ? _b : 0;
                            if (typeof url !== 'string' ||
                                newCreationTime < oldCreationTime ||
                                typeof fileID !== 'string') {
                                continue;
                            }
                            newFile = fileID !== ((_c = this.store.idLists[name_2]) === null || _c === void 0 ? void 0 : _c.fileID) &&
                                newCreationTime >= oldCreationTime;
                            if ((Object.prototype.hasOwnProperty.call(lookup, name_2) &&
                                !Object.prototype.hasOwnProperty.call(this.store.idLists, name_2)) ||
                                newFile // when fileID changes, we reset the whole list
                            ) {
                                this.store.idLists[name_2] = {
                                    ids: {},
                                    readBytes: 0,
                                    url: url,
                                    fileID: fileID,
                                    creationTime: newCreationTime
                                };
                            }
                            fileSize = (_d = item.size) !== null && _d !== void 0 ? _d : 0;
                            readSize = (_e = this.store.idLists[name_2].readBytes) !== null && _e !== void 0 ? _e : 0;
                            if (fileSize <= readSize) {
                                continue;
                            }
                            promises.push(this.genFetchIDList(name_2, url, readSize));
                        }
                        IDListUtil_1["default"].removeOldIdLists(this.store.idLists, lookup);
                        return [4 /*yield*/, Promise.all(promises.map(function (p) { return p["catch"](); }))];
                    case 7:
                        _h.sent();
                        if (!this.dataAdapter) return [3 /*break*/, 9];
                        return [4 /*yield*/, IDListUtil_1["default"].saveToDataAdapter(this.hashedSDKKey, this.dataAdapter, this.store.idLists, lookup)];
                    case 8:
                        _h.sent();
                        _h.label = 9;
                    case 9: return [3 /*break*/, 12];
                    case 10:
                        e_5 = _h.sent();
                        error = e_5;
                        return [3 /*break*/, 12];
                    case 11:
                        Diagnostics_1["default"].mark.getIDListSources.process.end({
                            success: !error
                        });
                        return [7 /*endfinally*/];
                    case 12: return [2 /*return*/, { synced: !error, error: error }];
                }
            });
        });
    };
    SpecStore.prototype.genFetchIDList = function (name, url, readSize) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var threwNetworkError, res, markerID, shouldLog, diagnostics, fetcher, e_6, contentLength, length_1, _c, _d, _e, e_7;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        threwNetworkError = false;
                        res = null;
                        ++this.getIDListCallCount;
                        markerID = String(this.getIDListCallCount);
                        shouldLog = this.getIDListCallCount % 50 === 1;
                        diagnostics = shouldLog ? Diagnostics_1["default"].mark.getIDList : null;
                        _f.label = 1;
                    case 1:
                        _f.trys.push([1, 3, 4, 5]);
                        diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.networkRequest.start({
                            url: url,
                            markerID: markerID
                        });
                        fetcher = (_a = this.networkOverrideFunc) !== null && _a !== void 0 ? _a : safeFetch_1["default"];
                        return [4 /*yield*/, fetcher(url, {
                                method: 'GET',
                                headers: {
                                    Range: "bytes=".concat(readSize, "-")
                                }
                            })];
                    case 2:
                        res = _f.sent();
                        return [3 /*break*/, 5];
                    case 3:
                        e_6 = _f.sent();
                        threwNetworkError = true;
                        return [3 /*break*/, 5];
                    case 4:
                        diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.networkRequest.end({
                            statusCode: res === null || res === void 0 ? void 0 : res.status,
                            success: (_b = res === null || res === void 0 ? void 0 : res.ok) !== null && _b !== void 0 ? _b : false,
                            markerID: markerID
                        });
                        return [7 /*endfinally*/];
                    case 5:
                        if (threwNetworkError || !res) {
                            return [2 /*return*/];
                        }
                        _f.label = 6;
                    case 6:
                        _f.trys.push([6, 8, , 9]);
                        diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.process.start({ markerID: markerID });
                        contentLength = res.headers.get('content-length');
                        if (contentLength == null) {
                            throw new Error('Content-Length for the id list is invalid.');
                        }
                        length_1 = parseInt(contentLength);
                        if (typeof length_1 === 'number') {
                            this.store.idLists[name].readBytes += length_1;
                        }
                        else {
                            delete this.store.idLists[name];
                            throw new Error('Content-Length for the id list is invalid.');
                        }
                        _d = (_c = IDListUtil_1["default"]).updateIdList;
                        _e = [this.store.idLists, name];
                        return [4 /*yield*/, res.text()];
                    case 7:
                        _d.apply(_c, _e.concat([_f.sent()]));
                        diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.process.end({
                            success: true,
                            markerID: markerID
                        });
                        return [3 /*break*/, 9];
                    case 8:
                        e_7 = _f.sent();
                        OutputLogger_1["default"].debug(e_7);
                        diagnostics === null || diagnostics === void 0 ? void 0 : diagnostics.process.end({
                            success: false,
                            markerID: markerID
                        });
                        return [3 /*break*/, 9];
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    SpecStore.prototype.shutdown = function () {
        var _a;
        this.clearTimers();
        (_a = this.dataAdapter) === null || _a === void 0 ? void 0 : _a.shutdown();
    };
    SpecStore.prototype.shutdownAsync = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.shutdown();
                        return [4 /*yield*/, this.rulesetsSyncPromise()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.idListsSyncPromise()];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    SpecStore.prototype.clearRulesetsSyncTimer = function () {
        if (this.rulesetsSyncTimer != null) {
            clearInterval(this.rulesetsSyncTimer);
            this.rulesetsSyncTimer = null;
        }
    };
    SpecStore.prototype.clearIdListsSyncTimer = function () {
        if (this.idListsSyncTimer != null) {
            clearInterval(this.idListsSyncTimer);
            this.idListsSyncTimer = null;
        }
    };
    SpecStore.prototype.clearTimers = function () {
        this.clearRulesetsSyncTimer();
        this.clearIdListsSyncTimer();
    };
    SpecStore.prototype.setInitialUpdateTime = function () {
        this.initialUpdateTime =
            this.lastUpdateTime === 0 ? -1 : this.lastUpdateTime;
    };
    return SpecStore;
}());
exports["default"] = SpecStore;
