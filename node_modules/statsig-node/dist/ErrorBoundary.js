"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.ExceptionEndpoint = void 0;
var Diagnostics_1 = __importDefault(require("./Diagnostics"));
var Errors_1 = require("./Errors");
var OutputLogger_1 = __importDefault(require("./OutputLogger"));
var core_1 = require("./utils/core");
var safeFetch_1 = __importDefault(require("./utils/safeFetch"));
exports.ExceptionEndpoint = 'https://statsigapi.net/v1/sdk_exception';
var ErrorBoundary = /** @class */ (function () {
    function ErrorBoundary(sdkKey, optionsLoggingCopy, sessionID) {
        var _a;
        this.statsigMetadata = (0, core_1.getStatsigMetadata)();
        this.seen = new Set();
        this.sdkKey = sdkKey;
        this.optionsLoggingCopy = optionsLoggingCopy;
        this.statsigMetadata['sessionID'] = sessionID;
        this.networkOverrideFunc = (_a = optionsLoggingCopy.networkOverrideFunc) !== null && _a !== void 0 ? _a : null;
    }
    ErrorBoundary.prototype.swallow = function (task, ctx) {
        this.capture(task, function () {
            return undefined;
        }, ctx);
    };
    ErrorBoundary.prototype.capture = function (task, recover, ctx) {
        var _this = this;
        var markerID = null;
        try {
            markerID = this.beginMarker(ctx.caller, ctx.configName);
            var result = task(ctx);
            if (result instanceof Promise) {
                return result["catch"](function (e) {
                    return _this.onCaught(e, recover, ctx);
                });
            }
            this.endMarker(ctx.caller, true, markerID, ctx.configName);
            return result;
        }
        catch (error) {
            this.endMarker(ctx.caller, false, markerID, ctx.configName);
            return this.onCaught(error, recover, ctx);
        }
    };
    ErrorBoundary.prototype.setup = function (sdkKey) {
        this.sdkKey = sdkKey;
    };
    ErrorBoundary.prototype.onCaught = function (error, recover, ctx) {
        if (error instanceof Errors_1.StatsigUninitializedError ||
            error instanceof Errors_1.StatsigInvalidArgumentError ||
            error instanceof Errors_1.StatsigTooManyRequestsError) {
            throw error; // Don't catch these
        }
        if (error instanceof Errors_1.StatsigLocalModeNetworkError) {
            return recover(ctx, error);
        }
        OutputLogger_1["default"].error('[Statsig] An unexpected exception occurred.', error);
        this.logError(error, ctx);
        return recover(ctx, error);
    };
    ErrorBoundary.prototype.logError = function (error, ctx) {
        var _a, _b;
        try {
            if (!this.sdkKey || this.optionsLoggingCopy.disableAllLogging) {
                return;
            }
            var unwrapped = error !== null && error !== void 0 ? error : Error('[Statsig] Error was empty');
            var isError = unwrapped instanceof Error;
            var name_1 = isError && unwrapped.name ? unwrapped.name : 'No Name';
            var hasSeen = this.seen.has(name_1);
            if (ctx.bypassDedupe !== true && hasSeen) {
                return;
            }
            this.seen.add(name_1);
            var info = isError ? unwrapped.stack : this.getDescription(unwrapped);
            var body = JSON.stringify(__assign({ exception: name_1, info: info, statsigMetadata: (_a = this.statsigMetadata) !== null && _a !== void 0 ? _a : {}, statsigOptions: this.optionsLoggingCopy }, ctx.getContextForLogging()));
            var fetcher = (_b = this.networkOverrideFunc) !== null && _b !== void 0 ? _b : safeFetch_1["default"];
            fetcher(exports.ExceptionEndpoint, {
                method: 'POST',
                headers: {
                    'STATSIG-API-KEY': this.sdkKey,
                    'STATSIG-SDK-TYPE': (0, core_1.getSDKType)(),
                    'STATSIG-SDK-VERSION': (0, core_1.getSDKVersion)(),
                    'Content-Type': 'application/json'
                },
                body: body
            })["catch"](function () { });
        }
        catch (_c) {
            /* noop */
        }
    };
    ErrorBoundary.prototype.getDescription = function (obj) {
        try {
            return JSON.stringify(obj);
        }
        catch (_a) {
            return '[Statsig] Failed to get string for error.';
        }
    };
    ErrorBoundary.prototype.beginMarker = function (key, configName) {
        if (key == null) {
            return null;
        }
        var diagnostics = Diagnostics_1["default"].mark.api_call(key);
        if (!diagnostics) {
            return null;
        }
        var count = Diagnostics_1["default"].getMarkerCount('api_call');
        var markerID = "".concat(key, "_").concat(count);
        diagnostics.start({
            markerID: markerID,
            configName: configName
        }, 'api_call');
        return markerID;
    };
    ErrorBoundary.prototype.endMarker = function (key, wasSuccessful, markerID, configName) {
        if (key == null) {
            return;
        }
        var diagnostics = Diagnostics_1["default"].mark.api_call(key);
        if (!markerID || !diagnostics) {
            return;
        }
        diagnostics.end({
            markerID: markerID,
            success: wasSuccessful,
            configName: configName
        }, 'api_call');
    };
    return ErrorBoundary;
}());
exports["default"] = ErrorBoundary;
