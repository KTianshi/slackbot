import DynamicConfig from './DynamicConfig';
import { FeatureGate } from './FeatureGate';
import { IDataAdapter } from './interfaces/IDataAdapter';
import { IUserPersistentStorage, UserPersistedValues } from './interfaces/IUserPersistentStorage';
import Layer from './Layer';
import LogEvent from './LogEvent';
import { StatsigUser } from './StatsigUser';
import { HashingAlgorithm } from './utils/Hashing';
export type RulesUpdatedCallback = (rulesJSON: string, time: number) => void;
export type RetryBackoffFunc = (retriesRemaining: number) => number;
export type StatsigEnvironment = {
    tier?: 'production' | 'staging' | 'development' | string;
    [key: string]: string | undefined;
};
export type InitStrategy = 'await' | 'lazy' | 'none';
export interface LoggerInterface {
    debug?(message?: any, ...optionalParams: any[]): void;
    info?(message?: any, ...optionalParams: any[]): void;
    warn(message?: any, ...optionalParams: any[]): void;
    error(message?: any, ...optionalParams: any[]): void;
    logLevel: 'none' | 'debug' | 'info' | 'warn' | 'error';
}
export type NetworkOverrideFunc = (url: string, params: RequestInit) => Promise<Response>;
export type EvaluationCallbacks = {
    gateCallback?: (gate: FeatureGate, user: StatsigUser, event: LogEvent) => void;
    dynamicConfigCallback?: (config: DynamicConfig, user: StatsigUser, event: LogEvent) => void;
    experimentCallback?: (config: DynamicConfig, user: StatsigUser, event: LogEvent) => void;
    layerCallback?: (layer: Layer, user: StatsigUser) => void;
    layerParamCallback?: (layer: Layer, paramName: string, user: StatsigUser, event: LogEvent) => void;
};
export type ExplicitStatsigOptions = {
    api: string;
    apiForDownloadConfigSpecs: string;
    apiForGetIdLists: string;
    fallbackToStatsigAPI: boolean;
    networkOverrideFunc: NetworkOverrideFunc | null;
    bootstrapValues: string | null;
    environment: StatsigEnvironment | null;
    rulesUpdatedCallback: RulesUpdatedCallback | null;
    logger: LoggerInterface;
    localMode: boolean;
    initTimeoutMs: number;
    dataAdapter: IDataAdapter | null;
    rulesetsSyncIntervalMs: number;
    idListsSyncIntervalMs: number;
    loggingIntervalMs: number;
    loggingMaxBufferSize: number;
    disableDiagnostics: boolean;
    initStrategyForIP3Country: InitStrategy;
    initStrategyForIDLists: InitStrategy;
    postLogsRetryLimit: number;
    postLogsRetryBackoff: RetryBackoffFunc | number;
    disableRulesetsSync: boolean;
    disableIdListsSync: boolean;
    disableAllLogging: boolean;
    userPersistentStorage: IUserPersistentStorage | null;
    evaluationCallback?: (config: FeatureGate | DynamicConfig | Layer) => void;
    evaluationCallbacks?: EvaluationCallbacks;
};
/**
 * An object of properties for initializing the sdk with advanced options
 */
export type StatsigOptions = Partial<ExplicitStatsigOptions>;
export declare function OptionsWithDefaults(opts: StatsigOptions): ExplicitStatsigOptions;
export declare function OptionsLoggingCopy(options: Record<string, unknown>): StatsigOptions;
export type PersistentAssignmentOptions = {
    enforceTargeting?: boolean;
};
export type CheckGateOptions = CoreApiOptions;
export type GetConfigOptions = CoreApiOptions;
export type GetExperimentOptions = CoreApiOptions & {
    userPersistedValues?: UserPersistedValues | null;
    persistentAssignmentOptions?: PersistentAssignmentOptions;
};
export type GetLayerOptions = CoreApiOptions & {
    userPersistedValues?: UserPersistedValues | null;
    persistentAssignmentOptions?: PersistentAssignmentOptions;
};
export type CoreApiOptions = {
    disableExposureLogging?: boolean;
};
export interface ClientInitializeResponseValueOverride {
    value?: Record<string, unknown>;
}
export interface ClientInitializeResponseExperimentOverride extends ClientInitializeResponseValueOverride {
    groupName?: string;
}
export type ClientInitializeResponseOptions = {
    hash?: HashingAlgorithm;
    includeLocalOverrides?: boolean;
    /**
     * Overrides for the generated client initialize response.
     * To override an experiment, use the dynamicConfigs object. You can override
     * the value directly with the 'value' property, or set the 'groupName' property
     * to use the value associated with that group.
     *
     * @example
     * {
     *   overrides: {
     *     featureGates: {
     *       'my_gate': true,             // Override gate value to true
     *     },
     *
     *     dynamicConfigs: {
     *       'price_config': {
     *         value: { price: 9.99 }     // Override value only
     *       },
     *       'color_experiment': {
     *         groupName: 'Control'       // Override group assignment only
     *       },
     *       'spacing_experiment': {
     *         value: { spacing: 64 },    // Override both value and
     *         groupName: 'Variant_B'     // group assignment
     *       }
     *     },
     *
     *     layers: {
     *       'my_layer': {
     *         value: { param: 123 }      // Override layer value
     *       }
     *     }
     *   }
     * }
     *
     */
    overrides?: {
        featureGates?: Record<string, boolean>;
        dynamicConfigs?: Record<string, ClientInitializeResponseExperimentOverride>;
        layers?: Record<string, ClientInitializeResponseValueOverride>;
    };
};
